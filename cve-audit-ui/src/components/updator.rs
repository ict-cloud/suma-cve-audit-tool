// component to refresh/update the data
use std::rc::Rc;
use yew::prelude::*;
use yew_hooks::use_async;

// reducer's Action
enum UpdateAction {
    Update,
}

/// reducer's State
struct CounterState {
    counter: i32,
}

impl Default for CounterState {
    fn default() -> Self {
        Self { counter: 1 }
    }
}

impl Reducible for CounterState {
    /// Reducer Action Type
    type Action = UpdateAction;

    /// Reducer Function
    fn reduce(self: Rc<Self>, _action: Self::Action) -> Rc<Self> {
        let next_ctr = self.counter + 1;

        Self { counter: next_ctr }.into()
    }
}

#[function_component(UseReducer)]
pub fn reducer() -> Html {
    // The use_reducer hook takes an initialization function which will be called only once.
    let counter = use_reducer(CounterState::default);

    let state = use_async(async move { api_call().await });

    let update_onclick = {
        let counter = counter.clone();
        Callback::from(move |_| {
            state.run();
            counter.dispatch(UpdateAction::Update)
        })
    };

    html! {
        <div class="btn-group me-2">
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick={update_onclick}>{"Update Data"}</button>
        </div>
    }
}

async fn api_call() -> Result<String, String> {
    match reqwest::get("/api/updator").await {
        Ok(_) => Ok(String::from("Ok")),
        Err(_) => Err(String::from("NOK")),
    }
}
