use crate::persistence::rdbms::*;
use sqlx::prelude::*;
use sqlx::sqlite::SqliteConnectOptions;
use sqlx::Result;
use std::{str::FromStr, path::PathBuf};

fn prereq_db_file() {
    // create db path if it not exists
    if !std::path::Path::new(db_path().as_str()).exists() {
        match std::fs::create_dir(db_path().as_str()) {
            Err(e) => log::error!("Unable to create directory: {}", e),
            Ok(()) => log::info!("Directory created"),
        };
    }
}

pub async fn setup() -> Result<()> {
    prereq_db_file();

    let setup_stmt = r#"
        begin;
            CREATE TABLE IF NOT EXISTS errata (
                suse_id INTEGER UNIQUE,
                date REAL NOT NULL,
                update_date REAL NOT NULL,
                advisory_type TEXT,
                advisory_name TEXT NOT NULL UNIQUE,
                advisory_synopsis TEXT
            );
            CREATE TABLE IF NOT EXISTS cve (
                id TEXT PRIMARY KEY,
                score REAL
            );
            CREATE TABLE IF NOT EXISTS errata_cve (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id)
            );
            CREATE TABLE IF NOT EXISTS cve_systems (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                affected_systems_cnt INTEGER,
                last_checked_date REAL
            );
            CREATE TABLE IF NOT EXISTS audit_data (
                id integer primary key AUTOINCREMENT,
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
                audit_date REAL NOT NULL,
                auditor TEXT,
                responsible TEXT,
                status TEXT NOT NULL,
                assessment TEXT NOT NULL,
                assess_score REAL,
                assessment_comment TEXT
            );
            CREATE TABLE IF NOT EXISTS audit_trail (
                audit_id integer unique,
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
                audit_date REAL NOT NULL,
                auditor TEXT,
                responsible TEXT,
                status TEXT NOT NULL,
                assessment TEXT NOT NULL,
                assess_score REAL,
                assessment_comment TEXT
            );
        COMMIT;
    "#;

    let idx_setup_stmt = r#"
        CREATE INDEX IF NOT EXISTS "cve_systems.i#cve_id" ON "cve_systems" ("cve_id");
        CREATE INDEX IF NOT EXISTS "errata_cve.i#cve_id-errata_id" ON "errata_cve" (
            "cve_id",
            "errata_id"
        );
        CREATE INDEX IF NOT EXISTS "audit_trail.i#errata_id" ON "audit_trail" ("errata_id");
        CREATE INDEX IF NOT EXISTS "audit_data.i#errata_id" ON "audit_data" ("errata_id");
        CREATE INDEX IF NOT EXISTS "errata.i#suse_id" ON "errata" ("suse_id");
    "#;

    let mut full_path: PathBuf = PathBuf::from(db_path());
    full_path.push(DB_NAME);

    let mut conn = SqliteConnectOptions::from_str(full_path.to_str().unwrap())?
        .create_if_missing(true)
        .connect()
        .await?;

    _ = match sqlx::query(setup_stmt).execute(&mut conn).await {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    };

    _ = match sqlx::query(idx_setup_stmt).execute(&mut conn).await {
        Ok(_) => Ok(()),
        Err(e) => Err(e),
    };

    conn.close();

    Ok(())
}
