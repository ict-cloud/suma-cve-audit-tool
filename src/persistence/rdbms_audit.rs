use crate::persistence::utils::convert_jd;
use crate::persistence::rdbms::open_pool;
use cve_audit_types::*;
use sqlx::{Row, Result};
use serde_json;
use futures::TryStreamExt;

pub async fn errata_get_audit_trail(i_errata_id: u32) ->  Vec<ErrataAuditData> {
    let mut aud_trail: Vec<ErrataAuditData> = Vec::new();

    let sel = r#"
    select * from (
        select  id as audit_id,
                errata_id,
                audit_date,
                auditor,
                responsible,
                status,
                assessment,
                assess_score,
                assessment_comment
        from    audit_data
        where   errata_id = ?
        union 
        select  audit_id,
                errata_id,
                audit_date,
                auditor,
                responsible,
                status,
                assessment,
                assess_score,
                assessment_comment
        from    audit_trail
        where   errata_id = ?
    ) order by audit_date desc;"#;

    let mut rows = sqlx::query(sel).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        println!("do something with the row");
    }

    aud_trail
}

pub async fn get_audit_for_errata(i_errata_id: u32) -> ErrataAuditData {

    let sel = r#"
      select * from audit_data where errata_id = ?
    "#;
    let conn = open_pool();

    let rows = sqlx::query(sel)
        .bind(i_errata_id)
        .fetch_optional(&conn).await.unwrap();
    let ead: ErrataAuditData = if let Some(row) = rows {
        ErrataAuditData{
            id: row.try_get(0).unwrap(),
            errata_id: row.try_get(1).unwrap(),
            audit_date: convert_jd(row.try_get(2).unwrap()),
            auditor: row.try_get(3).unwrap(),
            resp: row.try_get(4).unwrap(),
            status: serde_json::from_str(row.try_get(5).unwrap()).unwrap(),//AuditStatus::New, // needs to be annotated a sqlx::type
            assessment_verdict: serde_json::from_str(row.try_get(6).unwrap()).unwrap(),
            assessed_score: row.try_get(7).unwrap(),
            assessment_comment: row.try_get(8).unwrap()
        }
      } else {
        ErrataAuditData{
            id: 0,
            errata_id: 0,
            audit_date: String::from(""),
            auditor: String::from(""),
            resp: String::from(""),
            status: AuditStatus::New,
            assessment_verdict: AuditAssessment::Unclear,
            assessed_score: 0.0,
            assessment_comment: String::from("")
        }
    };
    
    ead
}

pub async fn write_audit_data(i_ad: ErrataAuditData) -> Result<()> {
    //log::debug!("Form data for writing received {:?}", i_ad);

    // CREATE TABLE IF NOT EXISTS audit_data (
    //     id integer primary key,
    //     errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
    //     audit_date REAL NOT NULL,
    //     auditor TEXT,
    //     responsible TEXT,
    //     status TEXT NOT NULL,
    //     assessment TEXT NOT NULL,
    //     assess_score REAL,
    //     assessment_comment TEXT
    // );

    // batch execute
    // first insert legacy record to audit trail
    // second delete legqcy records
    // insert new record
    
    
    let stmt = r#"insert into audit_data (
        errata_id,
        auditor,
        responsible,
        status,
        assessment,
        assess_score,
        assessment_comment,
        audit_date
        ) VALUES 
        (?1, ?2, ?3, ?4, ?5, ?6, ?7, julianday('now'));"#;

    let ins = sqlx::query(stmt)
        .bind(&i_ad.errata_id)
        .bind(&i_ad.auditor)
        .bind(&i_ad.resp)
        .bind(serde_json::to_string(&i_ad.status).unwrap_or_default())
        .bind(serde_json::to_string(&i_ad.assessment_verdict).unwrap_or_default())
        .bind(&i_ad.assessed_score)
        .bind(&i_ad.assessment_comment)
        .execute(&open_pool()).await;

    match ins {
        Ok(r) => println!("Successfully inserted {:?}", r),
        Err(e)  => println!("Error during insert of audit_data: {}", e),
    };

    Ok(())
}