use reqwasm::*;
use yew::prelude::*;
use yew_router::prelude::*;
use wasm_bindgen_futures::*;
use crate::route;

#[derive(Clone, Debug, PartialEq, Properties, Default)]
pub struct ErrataAPIProps{
    pub url: String,
}

#[function_component(Erratalist)]
pub fn erratalist(props: &ErrataAPIProps) -> Html {
    //let errata_api = use_context::<ErrataAPIProps>().expect("no ctx found");
    let errata = use_state(|| vec![]);
    let url = props.url.clone();
    {
        let errata = errata.clone();
        let url = props.url.clone();
        use_effect_with_deps(move |_| {
            let errata = errata.clone();
            let url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_errata: Vec<cve_audit_types::ErrataExtended> = reqwasm::http::Request::get(url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                errata.set(fetched_errata);
            });
            || ()
        }, ());
    }

    html! {
        <div>
            { render_list(errata)}
        </div>
    }

}

fn render_list(erratas: yew::UseStateHandle<Vec<cve_audit_types::ErrataExtended>>) -> Html {
    let list = &*erratas.clone();
    if list.len() > 0 {
        html! {
            <div class={classes!("list", "table-responsive")}>
              <table class={classes!("table", "table-striped", "table-sm")}>
                <thead>
                <tr>
                  <th scope={"col"}>{"ID"}</th>
                  <th scope={"col"}>{"Update Date"}</th>
                  <th scope={"col"} style="max-width: 120px">{"SUSE Errata"}</th>
                  <th scope={"col"} style="max-width: 220px">{"Synopsis"}</th> 
                  <th scope={"col"}>{"CVEs"}</th>
                  <th scope={"col"}>{"Affected"}</th>
                  <th scope={"col"}/>
                </tr>
                </thead>
                <tbody>
                  { list.iter().map(|c| view_errata(c)).collect::<Html>() }
                </tbody>
              </table>
            </div>
        }
    } else {
        html! {
            <div class={classes!("loading")}>{"loading..."}</div>
        }
    }
}

fn view_errata(errata: &cve_audit_types::ErrataExtended) -> Html {
    let cves = errata.cves.to_owned();
    html! {
        <tr>
          <td>{errata.id.to_owned()}</td>
          <td>{errata.update_date.to_owned()}</td>
          <td style="max-width: 120px">{errata.advisory_name.to_owned()}</td>
          <td style="max-width: 220px">{errata.advisory_synopsis.to_owned()}</td>
          <td><ul>{ cves.iter().map(|cve| view_cve(cve)).collect::<Html>() }</ul></td>
          <td> { if errata.sys_affected { html!{{"YES"}}} else { html!{{"NO"}} }}</td>
          <td><Link<route::AppRoute> to={route::AppRoute::Errata { i_errata_id: errata.id.to_string() }}> {"Details"} </Link<route::AppRoute>></td>
        </tr>
    }
}

fn view_cve(cve: &String) -> Html {
    html! {
      <li>{cve}</li>
    }
}