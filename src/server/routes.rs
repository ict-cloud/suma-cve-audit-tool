use crate::server::api_handlers::*;
use crate::server::handlers::*;
use rust_embed::RustEmbed;
use warp::{filters::BoxedFilter, Filter, Reply};

#[derive(RustEmbed)]
#[folder = "static"]
#[prefix = "static/"]
pub struct Asset;

pub fn stat_routes() -> BoxedFilter<(impl Reply,)> {
    let cors = warp::cors()
            .allow_any_origin()
            .allow_headers(vec![
            "User-Agent",
            "Sec-Fetch-Mode",
            "Referer",
            "Origin",
            "Access-Control-Request-Method",
            "Access-Control-Request-Headers",
            "Content-Type",
        ])
            .allow_methods(vec!["POST", "GET"]);

    // build the pages and define an index
    let index_html = warp::get()
        
        .and(warp::path::end())
        
        .and_then(serve_index)
        
        .boxed();
    // serve all static assets
    let stat = warp::path("static")
        
        .and(warp::path::tail())
        
        .and_then(serve)
        
        .boxed();
    // urls needed from yew app
    let list_cves = warp::path!("cve-overview")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();
    let errata_naff = warp::path!("not-affected")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();
    let errata_aff = warp::path!("affected")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();
    let errata_oth = warp::path!("other-errata")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();
    let errata_unrated = warp::path!("unrated")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();
    let errata_det = warp::path!("errata" / i32)
        .and(warp::path::end())
        .and_then(serve_idx)
        .boxed();
    let report_errataudit = warp::path!("report" / "errataudit")
        .and(warp::path::end())
        .and_then(serve_index)
        .boxed();

    // health
    let health_route = warp::path!("health").and_then(health_handler).boxed();

    index_html
        .or(stat)
        .or(health_route)
        .or(list_cves)
        .or(errata_naff)
        .or(errata_aff)
        .or(errata_oth)
        .or(errata_det)
        .or(errata_unrated)
        .or(report_errataudit)
        .with(cors)
        .boxed()
}

pub fn api_routes() -> BoxedFilter<(impl Reply,)> {
    let cors = warp::cors()
            .allow_any_origin()
            .allow_headers(vec![       
            "User-Agent",      
            "Sec-Fetch-Mode",       
            "Referer",       
            "Origin",         
            "Access-Control-Request-Method",           
            "Access-Control-Request-Headers",           
            "Content-Type",
        ])
            .allow_methods(vec!["POST", "GET"]);

    // build the pages and define an index
    let list_errata = warp::path!("api" / "geterrata")
        .and(warp::path::end())
        .and(warp::any().map(move || "".to_owned()))
        .and_then(erratalisthandler)
        .boxed();
    let list_secadv = warp::path!("api" / "getsecadvice" / String)
        .and(warp::path::end())
        .and_then(erratalisthandler)
        .boxed();
    let updator = warp::path!("api" / "updator")
        .and(warp::path::end())
        .and_then(updator_handler)
        .boxed();
    // errata with audit list
    let list_errata_w_audit = warp::path!("api" / "list" / "erratawithaudit")
        .and(warp::path::end())
        .and_then(errata_with_audit_list)
        .boxed();
    // detail view
    let detail = warp::path!("api" / "errata" / u32)
        .and(warp::path::end())
        .and_then(errata_details_handler)
        .boxed();
    // audit form
    let form = warp::path!("api" / "audit" / "submit")
        .and(warp::path::end())
        .and(warp::post())
        .and(warp::body::json())
        .and_then(audit_form_handler)
        .with(&cors)
        .boxed();
    // audit trail for errata
    let audtrail = warp::path!("api" / "errata" / u32 / "audittrail")
        .and(warp::path::end())
        .and_then(audit_trail_handler)
        .boxed();
    // current audit data record for an errata
    let aud_data = warp::path!("api" / "errata" / u32 / "auditrecord")
        .and(warp::path::end())
        .and_then(errata_audit_handler)
        .boxed();
    
    list_errata
        .or(list_secadv)
        .or(updator)
        .or(detail)
        .or(form)
        .or(audtrail)
        .or(aud_data)
        .or(list_errata_w_audit)
        .with(cors)
        .boxed()
}

