use yew::prelude::*;
use cve_audit_types::*;
use crate::details::audit_form::*;

#[derive(Properties, PartialEq)]
pub struct AuditTrailProps {
    pub errata_id: u32,
}

#[function_component(AuditTrailEntry)]
pub fn audit_trail_entry(audit_trail_props: &AuditTrailProps) -> Html {
    let empty_trail = cve_audit_types::ErrataAuditData{
        id: 0,
        errata_id: 0,
        audit_date: String::from("2022-01-01"),
        auditor: String::from(""),
        resp: String::from(""),
        status: AuditStatus::New,
        assessment_verdict: AuditAssessment::Unclear,
        assessed_score: 0.0,
        assessment_comment: String::from(""),
    };
    let audit_trail = use_state(|| empty_trail);
    let url = format!("http://localhost:8081/api/errata/{}/audittrail", audit_trail_props.errata_id);
    {
        let audit_trail = audit_trail.clone();
        use_effect_with_deps(move |url| {
            let audit_trail = audit_trail.clone();
            let url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_at: cve_audit_types::ErrataAuditData = reqwasm::http::Request::get(url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                audit_trail.set(fetched_at);
            });
            || ()
        }, url.clone());
    }

    html! {
        <div>
            {"List"}
            {render_item(audit_trail)}
        </div>
    }
}

#[function_component(AuditTrailList)]
pub fn audit_trail_list(audit_trail_props: &AuditTrailProps) -> Html {
    let audit_trail = use_state(|| vec![]);
    let do_audit = use_state_eq( || false); // should be context and no state variable!
    let onclick = {
        let do_audit = do_audit.clone();
        Callback::from(move |_| do_audit.set(*do_audit != true))
    };

    let url = format!("http://localhost:8081/api/errata/{}/audittrail", audit_trail_props.errata_id);
    {
        let audit_trail = audit_trail.clone();
        use_effect_with_deps(move |url| {
            let audit_trail = audit_trail.clone();
            let url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_at: Vec<cve_audit_types::ErrataAuditData> = reqwasm::http::Request::get(url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                audit_trail.set(fetched_at);
            });
            || ()
        }, url.clone());
    }

    html!{
        {
            if *do_audit {
                html!{ <AuditForm errata_id={audit_trail_props.errata_id} /> }
            } else if audit_trail.len() > 0 {
                html!{
                    <>
                    <div>
                        {"List"}
                        {render_list(audit_trail)}
                    </div>
                    <hr/>
                    <form>
                        <button {onclick} class="btn btn-primary">{"Edit"}</button>
                    </form>
                    </>
                }
            } else {
                html!{
                    <form>
                        <button {onclick} class="btn btn-primary">{"Add"}</button>
                    </form>
                }
            }
        }
    }
}

fn render_list(audit_trail: yew::UseStateHandle<Vec<cve_audit_types::ErrataAuditData>>) -> Html {
    html! {
        <div class={classes!("list", "table-responsive")}>
          <table class={classes!("table", "table-striped", "table-sm")}>
            <thead>
              <tr>
                <th scope={"col"}>{"Date"}</th>
                <th scope={"col"}>{"Status"}</th>
                <th scope={"col"}>{"Assessment"}</th>
                <th scope={"col"}>{"Assessed Score"}</th> 
                <th scope={"col"}>{"Auditor"}</th>
                <th scope={"col"}>{"Responsible"}</th>
              </tr>
            </thead>
            <tbody>
            { audit_trail.iter().map(|c| render_line(c)).collect::<Html>() }
            </tbody>
          </table>
        </div>
    }
}

fn render_line(line_item: &cve_audit_types::ErrataAuditData) -> Html {
    html! {
        <tr>
          <td>{&line_item.audit_date}</td>
          <td>{&line_item.status}</td>
          <td>{&line_item.assessment_verdict}</td>
          <td>{&line_item.assessed_score}</td>
          <td>{&line_item.auditor}</td>
          <td>{&line_item.resp}</td>
        </tr>
    }
}

fn render_item(audit_trail: yew::UseStateHandle<cve_audit_types::ErrataAuditData>) -> Html {
    let aud_trail = &*audit_trail.clone();
    if aud_trail.id != 0 {
        html! {
            <div class={classes!("list", "table-responsive")}>
              <table class={classes!("table", "table-striped", "table-sm")}>
                <thead>
                  <tr>
                    <th scope={"col"}>{"Date"}</th>
                    <th scope={"col"}>{"Status"}</th>
                    <th scope={"col"}>{"Assessment"}</th>
                    <th scope={"col"}>{"Assessed Score"}</th> 
                    <th scope={"col"}>{"Auditor"}</th>
                    <th scope={"col"}>{"Responsible"}</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>{&aud_trail.audit_date}</td>
                    <td>{&aud_trail.status}</td>
                    <td>{&aud_trail.assessment_verdict}</td>
                    <td>{&aud_trail.assessed_score}</td>
                    <td>{&aud_trail.auditor}</td>
                    <td>{&aud_trail.resp}</td>
                  </tr>
                </tbody>
              </table>
            </div>
        }
    } else {
        html! {
            <div class={classes!("loading")}>{"loading..."}</div>
        }
    }
}