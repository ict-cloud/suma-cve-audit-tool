use yew::prelude::*;
use crate::details::audit_trail::*;
use crate::details::audit_form::*;
use crate::details::trailstate::*;

#[derive(Properties, PartialEq)]
pub struct DetailProps {
    pub id: u32,
}

#[function_component(CveDetails)]
pub fn cvedetails() -> Html {
    html!{
        <div>
          <h2>{"CVE Detail Page"}</h2>
          <br/>
          <strong>{"Description"}</strong>
          <br/>
          {"Beschreibung des CVE mit einem l√§ngeren Text"}
          <br/>
          <strong>{"SUSE Errata"}</strong>
          <br/>
          {"Liste der SUSE Errate welche beinhaltet sind"}
          <br/>
        </div>
    }
}

#[function_component(ErrataDetails)]
pub fn erratadetails(detail_props: &DetailProps) -> Html {
    let url = format!("http://localhost:8081/api/errata/{}", detail_props.id);
    let empty_errata: cve_audit_types::ErrataExtended = cve_audit_types::ErrataExtended{
      id: 0,
      date: String::from(""),
      update_date: String::from(""),
      advisory_synopsis: String::from(""),
      advisory_type: String::from(""),
      advisory_name: String::from(""),
      cves: Vec::new(),
      sys_affected: false,
    };
    let errata = use_state(|| empty_errata );
    { // needed because of lifetime issues otherwise
        let errata = errata.clone();
        use_effect_with_deps(move |url| {
            let errata = errata.clone();
            let l_url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_errata: cve_audit_types::ErrataExtended = reqwasm::http::Request::get(l_url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                errata.set(fetched_errata);
            });
            || ()
        }, url.clone() ); // dependents here
    }

    html!{
        {render_details(errata)}
    }
}

fn render_details(entry: yew::UseStateHandle<cve_audit_types::ErrataExtended>) -> Html {
  let entry = &*entry.clone();

  // audit trail list
  let traillist = use_reducer_eq(||TrailState::default());

  let url = format!("http://localhost:8081/api/errata/{}/audittrail", entry.id);
  {
    let l_traillist = traillist.clone();
    use_effect_with_deps(move |url| {
        let l_traillist2 = l_traillist.clone();
        let l_url = url.clone();
        wasm_bindgen_futures::spawn_local(async move {
            let fetched_at: Vec<cve_audit_types::ErrataAuditData> = reqwasm::http::Request::get(l_url.as_str())
                .send()
                .await
                .unwrap()
                .json()
                .await
                .unwrap();
            l_traillist2.dispatch(TrailAction::Load(fetched_at));
        });
        move || ()
    }, url.clone());
  }

  let tmp_traillist = traillist.clone();
  let load_from_form: Callback<Vec<cve_audit_types::ErrataAuditData>> = Callback::from(move |audit_trail_v: Vec<cve_audit_types::ErrataAuditData>| {
    tmp_traillist.dispatch(TrailAction::Load(audit_trail_v));
  });

  html!{
    <>
    <div>
      <h2>{&entry.advisory_name}</h2>
      <br/>
      {&entry.advisory_synopsis}
      <br/>
      <br/>
      <strong>{"ID: "}</strong>{&entry.id}<br/>
      <strong>{"Errata Type: "}</strong>{&entry.advisory_type}<br/>
      <strong>{"Update Date: "}</strong>{&entry.update_date}<br/>
      <br/>
      <br/>
      <strong>{"CVEs"}</strong>
      <br/>
      <ul>{ entry.cves.iter().map(|cve| render_cve_details(cve)).collect::<Html>() }</ul>
      <br/>
    </div>
    <div class="col-12">
      // move audittraillist and audit form as siblings of the details page
      // use a reducible for updating the list, all is triggered from the details page
      //             details (manages state and trail_list)
      //             |     |
      //           trail  form
      <AuditTrailList audit_trail_list = { traillist.audit_trail_list.clone() }/>
      <hr/>
        <AuditForm errata_id={ entry.id } trail_length={traillist.audit_trail_list.len()} update_list = {load_from_form} />
    </div>
    </>
  }
}

fn render_cve_details(cve: &str) -> Html {
  html!{
    <li>{cve}</li>
  }
}