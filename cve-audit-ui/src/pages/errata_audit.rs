use crate::route;
use cve_audit_types::AuditAssessment;
use reqwasm::http::Request;
use wasm_bindgen_futures::spawn_local;
use yew::prelude::*;
use yew_router::prelude::*;
use crate::components::*;


/// showing errata with the current audit data
/// either for all records or just for a dedicated timerange
#[function_component(ErrataAuditPage)]
pub fn errata_audit_page() -> Html {
    html!{
        <>
        <header::Header/>
        <div class="container-fluid">
          <div class="row">
            <side_nav::SideNav/>
            <main class="col-md-9 ms-sm-auto col-lg-10 px-md-4">
                <top_nav::TopNav/>
                <ErrataAuditReport/>
            </main>
          </div>
        </div>
        </>
    }
}


#[function_component(ErrataAuditReport)]
fn errata_audit_report() -> Html {
    let query_url = format!("{}{}", crate::BACKEND, "/api/list/erratawithaudit");
    let erratas = use_state(|| vec![]);
    {
        // needed because of lifetime issues otherwise
        let errata = erratas.clone();
        use_effect_with_deps(
            move |_| {
                let errata = errata.clone();
                //let url = url.clone();
                spawn_local(async move {
                    let fetched_errata: Vec<cve_audit_types::ErrataWithAudit> =
                        Request::get(&query_url)
                            .send()
                            .await
                            .unwrap()
                            .json()
                            .await
                            .unwrap();
                    errata.set(fetched_errata);
                });
                || ()
            },
            (),
        ); // dependents here
    }
    
    html!{
        { render_list(erratas.to_owned()) }
    }
}

fn render_list(erratas: yew::UseStateHandle<Vec<cve_audit_types::ErrataWithAudit>>) -> Html {
    let list = &*erratas.clone();
    if list.len() > 0 {
        html! {
            <div class={classes!("list", "table-responsive")}>
              <table class={classes!("table", "table-striped", "table-sm")}>
                <thead>
                <tr>
                  <th scope={"col"}>{"ID"}</th>
                  <th scope={"col"} style="max-width: 220px">{"SUSE Errata"}</th>
                  <th scope={"col"} style="max-width: 200px">{"CVEs"}</th>
                  <th scope={"col"}>{"Audit Date"}</th>
                  <th scope={"col"} style="max-width: 130px">{"Auditor / Responsible"}</th>
                  <th scope={"col"}>{"Score"}</th>
                  <th scope={"col"}>{"Assessment"}</th>
                  <th scope={"col"}/>
                </tr>
                </thead>
                <tbody>
                  { list.iter().map(|c| view_errata(c)).collect::<Html>() }
                </tbody>
              </table>
            </div>
        }
    } else {
        html! {
            <div class={classes!("loading")}>{"loading..."}</div>
        }
    }
}

// make badge color for assessment-verdict depending on the value
// color scores > 8
fn view_errata(errata: &cve_audit_types::ErrataWithAudit) -> Html {
    let cves = errata.cves.to_owned();
    html! {
        <tr>
          <td>{errata.id.to_owned()}</td>
          <td style="max-width: 220px">{errata.advisory_name.to_owned()}{" - "}{errata.advisory_synopsis.to_owned()}</td>
          <td style="max-width: 200px">{ cves.join(", ").as_str() }</td>
          <td>{ errata.audit_data.audit_date.as_str() }</td>
          <td style="max-width: 130px">{ errata.audit_data.auditor.as_str() } {" / "} {errata.audit_data.resp.as_str()}</td>
          <td>{ errata.audit_data.assessed_score }</td>
          <td>{assessment_with_badge(errata.audit_data.assessment_verdict.to_owned())}</td>
          <td><Link<route::AppRoute> to={route::AppRoute::Errata { i_errata_id: errata.id }}> {"Details"} </Link<route::AppRoute>></td>
        </tr>
    }
}

fn assessment_with_badge(i_assessment: cve_audit_types::AuditAssessment) -> Html {
    let badge_colour = match i_assessment {
        AuditAssessment::NotAffected => "bg-success",
        AuditAssessment::AffectedRegularPatching => "bg-primary",
        AuditAssessment::AffectedImmediatePatching => "bg-danger",
        AuditAssessment::AffectedPatched => "bg-success",
        AuditAssessment::Unclear => "bg-warning",
    };

    html!{
        <span class={classes!("badge", badge_colour)}>{ i_assessment.to_string().as_str() }</span>
    }
}