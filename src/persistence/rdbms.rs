use futures::TryStreamExt;
use sqlx::Row;
use rusqlite::{Connection, Result, params, OpenFlags};
use once_cell::sync::OnceCell;
use sqlx::sqlite::SqlitePool;
use tokio::runtime::Runtime;


// Constants
const DB_NAME: &str = "suse_errata.sqlite";
const POOL: OnceCell<SqlitePool> = OnceCell::new();

// ENUM
#[derive(Debug, PartialEq)]
pub enum SecAdvisoryKind{
    Affected,
    Unaffected,
}

/*  SETUP of Relational database
* suse_errata
*    data from suse errata
* 
*  CVE
*    data for CVE (id, name, score)
*
*  Audit Evaluation
*    Data of the evaluation
*    date, person, result, 
*
*  errata_cve
*    Relations from errata to cve
*  
*  errata_audit
*    Relations from errata to audits
*
*  cve_systems
*    systems affected by cve
*/ 
fn open_db() -> Connection {

    let dir = std::env::current_exe().unwrap().parent().expect("Executable must be in some directory").to_owned();
    let mut path = dir.join("db");
    path.push(DB_NAME);

    Connection::open_with_flags(path.to_str().unwrap(), OpenFlags::SQLITE_OPEN_READ_WRITE | OpenFlags::SQLITE_OPEN_CREATE | OpenFlags::SQLITE_OPEN_FULL_MUTEX).unwrap()
}

fn open_pool() -> SqlitePool {
    match POOL.get() {
        Some(p) => p.to_owned(),
        None => init_pool().to_owned(),
    }
}

fn init_pool() -> SqlitePool {

    let dir = std::env::current_exe().unwrap().parent().expect("Executable must be in some directory").to_owned();
    let mut path = dir.join("db");
    path.push(DB_NAME);

    let async_pool = async move {SqlitePool::connect(path.to_str().unwrap()).await};

    let pool_thread = std::thread::spawn( || {Runtime::new().unwrap().block_on(async_pool)}).join().unwrap();

    let p = POOL.get_or_try_init( || pool_thread ).unwrap().to_owned();

    p
}

// current path
fn db_path() -> String {
    let dir = std::env::current_exe().unwrap().parent().expect("Executable must be in some directory").to_owned();
    let path = dir.join("db");

    // return path string
    path.to_str().unwrap().to_owned()
}

pub fn setup() -> Result<()> {
    // create db path if it not exists
    if !std::path::Path::new(db_path().as_str()).exists() {
        match std::fs::create_dir(db_path().as_str()) {
            Err(e) => log::error!("Unable to create directory: {}", e),
            Ok(()) => log::info!("Directory created"),
        };
    }

    let conn = open_db();

    let setup_stmt = r#"
        begin;
            CREATE TABLE IF NOT EXISTS errata (
                suse_id INTEGER UNIQUE,
                date REAL NOT NULL,
                update_date REAL NOT NULL,
                advisory_type TEXT,
                advisory_name TEXT NOT NULL UNIQUE,
                advisory_synopsis TEXT
            );
            CREATE TABLE IF NOT EXISTS cve (
                id TEXT PRIMARY KEY,
                score REAL
            );
            CREATE TABLE IF NOT EXISTS errata_cve (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id)
            );
            CREATE TABLE IF NOT EXISTS cve_systems (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                affected_systems_cnt INTEGER,
                last_checked_date REAL
            );
        COMMIT;
    "#;
    
    match conn.execute_batch(setup_stmt) {
         Ok(())   => log::info!("Tables setup"),
         Err(err) => log::error!("setup failed: {}", err),
    };

    Ok(())
}

pub fn store_ee(i_errata_ext: &cve_audit_types::ErrataExtended) -> Result<()> {
    let conn = open_db();
    let stmt_errata = r#"INSERT INTO errata VALUES (?1, julianday(?2), julianday(?3), ?4, ?5, ?6) ON CONFLICT DO NOTHING"#;
    let mut stmt_cve = conn.prepare_cached(r#"INSERT INTO cve (id) VALUES (?) ON CONFLICT (id) DO NOTHING"#)?;
    let mut stmt_rel = conn.prepare_cached(r#"INSERT INTO errata_cve (cve_id, errata_id) VALUES (?1, ?2) ON CONFLICT DO NOTHING"#)?;

    // first insert the errata
    match conn.execute(stmt_errata, 
        params![i_errata_ext.id, 
            i_errata_ext.date, 
            i_errata_ext.update_date, 
            i_errata_ext.advisory_type, 
            i_errata_ext.advisory_name, 
            i_errata_ext.advisory_synopsis],)
    {
        Ok(inserted) => log::info!("Rows inserted {}", inserted),
        Err(err)     => log::error!("insert failed: {}", err),
    };


    for c in i_errata_ext.cves.iter() {

        match stmt_cve.execute(params![c]) {
            Ok(inserted) => log::info!("store_cve.cve: rows inserted {}", inserted),
            Err(err)     => log::error!("store_cve insert failed: {}", err),
        };
        
        match stmt_rel.execute(params![c, i_errata_ext.id]) {
            Ok(inserted) => log::info!("store_cve.errata_cve: rows inserted {}", inserted),
            Err(err)     => log::error!("errata_cve insert failed: {}", err),
        };
    }

    Ok(())
}

pub fn store_cve_affsystem(i_cve: &str, i_num_asys: i32) -> Result<()> {

    let conn = open_db();
    let mut stmt_cve = conn.prepare_cached(r#"INSERT INTO cve (id) VALUES (?) ON CONFLICT (id) DO NOTHING"#)?;
    let mut stmt = conn.prepare_cached(r#"INSERT INTO cve_systems (cve_id, affected_systems_cnt, last_checked_date) VALUES (?1, ?2, julianday('now'));"#)?;

    match stmt_cve.execute(params![i_cve]) {
        Ok(inserted) => log::info!("store_cve_affsystem: rows inserted {}", inserted),
        Err(err)     => log::error!("store_cve_affsystem insert failed: {}", err),
    }; 

    match stmt.execute(params![i_cve, i_num_asys]) {
        Ok(inserted) => log::info!("store_cve_affsystem: rows inserted {}", inserted),
        Err(err)     => log::error!("store_cve_affsystem insert failed: {}", err),
    }; 

    Ok(())
}

fn convert_jd(i_jd: f64) -> String {
    let epoch = hifitime::Epoch::from_jde_tdb(i_jd).as_gregorian_utc_str();
    let (d, _) = epoch.split_once("T").unwrap();
    d.to_string()
}

pub async fn get_errataext() -> Vec<cve_audit_types::ErrataExtended> {
    let mut ere: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let sel = r#"
      select * from errata order by update_date desc
    "#;

    let db = open_db();

    let mut stmt = db.prepare(sel).unwrap();
    let mut rows = stmt.query([]).unwrap();
    while let Some(row) = rows.next().unwrap() {
        let id = row.get(0).unwrap();
        let erta = cve_audit_types::ErrataExtended{
            id: id,
            date: convert_jd(row.get::<_, f64>(1).unwrap()),
            update_date: convert_jd(row.get::<_, f64>(2).unwrap()),
            advisory_synopsis: row.get(5).unwrap(),
            advisory_type: row.get(3).unwrap(),
            advisory_name: row.get(4).unwrap(),
            cves: get_linked_cves(&id),
            sys_affected: get_affected_sys(&id),
        };
        ere.push(erta);
    }
    ere
}

fn get_linked_cves(i_errata_id: &i32) -> Vec<String> {
    let mut lcves: Vec<String> = Vec::new();

    let sel = r#"
    select id from cve where id in (select cve_id from errata_cve where errata_id = ?); 
    "#;

    let db = open_db();
    let mut stmt = db.prepare(sel).unwrap();
    let res = stmt.query_map([i_errata_id], |row| row.get(0)).unwrap();

    for cve in res {
        lcves.push(cve.unwrap());
    }

    drop(stmt);
    drop(db);

    lcves
}

fn get_affected_sys(i_errata_id: &i32) -> bool {

    let sel = r#"
    select sum(affected_systems_cnt)
    from  cve_systems as cs
    where cs.cve_id in (select cve_id from errata_cve where errata_id = ?);
    "#;

    let db = open_db();
    let cnt: i32 = db.query_row(sel, params![i_errata_id], |row| row.get(0)).unwrap_or(0);

    cnt > 0
}

async fn get_aff_sys(i_errata_id: &i32) -> bool {
    //open_pool();
    let sel = r#"
    select sum(affected_systems_cnt) as aff_sys
    from  cve_systems as cs
    where cs.cve_id in (select cve_id from errata_cve where errata_id = ?);
    "#;

    let rec = sqlx::query(sel).bind(i_errata_id).fetch_one(&open_pool()).await.expect("Some error message");
    let a: i32 = rec.get("aff_sys");
    a > 0
}

pub async fn get_secadvisories(i_kind: SecAdvisoryKind) -> Vec<cve_audit_types::ErrataExtended> {
    let mut sa: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let stmt_aff = r#"
    select * 
    from errata 
    where advisory_type = "Security Advisory" 
    and suse_id in (
        select distinct errata_id 
        from errata_cve 
        where exists (select null 
                  from cve_systems 
                  where cve_systems.cve_id = errata_cve.cve_id 
                  and affected_systems_cnt > 0
        ))
    order by update_date desc;
    "#;

    let stmt_naff = r#"
    select * 
    from errata 
    where advisory_type = "Security Advisory" 
    and suse_id in (
        select distinct errata_id 
        from errata_cve 
        where exists (select null 
                  from cve_systems 
                  where cve_systems.cve_id = errata_cve.cve_id 
                  and affected_systems_cnt = 0
        ) and not exists (
            select null 
            from cve_systems 
            where cve_systems.cve_id = errata_cve.cve_id 
            and affected_systems_cnt > 0
        ))
    order by update_date desc;
    "#;

    //let db = open_db();

    // let mut stmt = match i_kind {
    //     SecAdvisoryKind::Affected   => { db.prepare(stmt_aff).unwrap() },
    //     SecAdvisoryKind::Unaffected => { db.prepare(stmt_naff).unwrap() },
    // };

    let stmt = match i_kind {
        SecAdvisoryKind::Affected   => stmt_aff,
        SecAdvisoryKind::Unaffected => stmt_naff,
    };

    //let mut rows = stmt.query([]).unwrap();
    let mut rows = sqlx::query(stmt).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        let id = row.try_get(0).unwrap();
        let erta = cve_audit_types::ErrataExtended{
            id: id,
            date: convert_jd(row.try_get(1).unwrap()),
            update_date: convert_jd(row.try_get(2).unwrap()),
            advisory_synopsis: row.try_get(5).unwrap(),
            advisory_type: row.try_get(3).unwrap(),
            advisory_name: row.try_get(4).unwrap(),
            cves: get_linked_cves(&id),
            sys_affected: get_aff_sys(&id).await,
        };
        sa.push(erta);
    }

    sa
}

pub async fn get_errata(i_id: i32) -> cve_audit_types::ErrataExtended {
    let mut ere: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let sel = r#"
      select * from errata where suse_id = ? order by update_date desc
    "#;

    //let db = open_db();

    //let mut stmt = db.prepare(sel).unwrap();
    //let mut rows = stmt.query([i_id]).unwrap();

    let mut rows = sqlx::query(sel)
                    .bind(i_id)
                    .fetch(&open_pool());

    // duplicate code!
    while let Some(row) = rows.try_next().await.unwrap() {
        //let id = row.get(0).unwrap();
        let erta = cve_audit_types::ErrataExtended{
            id: row.try_get(0).unwrap(),
            date: convert_jd(row.try_get(1).unwrap()),
            update_date: convert_jd(row.try_get(2).unwrap()),
            advisory_synopsis: row.try_get(5).unwrap(),
            advisory_type: row.try_get(3).unwrap(),
            advisory_name: row.try_get(4).unwrap(),
            cves: get_linked_cves(&i_id),
            sys_affected: get_aff_sys(&i_id).await,
        };
        ere.push(erta);
    }
    let ee = &ere[0];
    ee.clone()
}