
extern crate reqwest;
extern crate xmlrpc;
extern crate iso8601;

use xmlrpc::{Request, Transport, http::build_headers, http::check_response};
use reqwest::blocking::{Client, RequestBuilder, Response};
use std::collections::{HashMap, BTreeMap};
use serde::{Deserialize, Serialize};
use serde_derive::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use std::error::Error;
use chrono::{Duration, Utc};
use toml::Value;
use cve_audit_types::*;
use crate::persistence;


#[derive(Debug, Clone, Serialize, Deserialize)]
struct CveJson {
    cve_id: String, 
    date: String,
    update_date: String,
    advisory_synopsis: String,
    advisory_type: String,
    advisory_name: String,
}

#[derive(Debug)]
struct SumaClient {
    rpcurl: String,
    user: String,
    pw: String,
    session: String,
}

/* /// Custom transport that adds a cookie header.
struct SumaTransport(RequestBuilder);

impl Transport for SumaTransport {
    type Stream = Response;

    fn transmit(self, request: &Request) -> Result<Self::Stream, Box<dyn Error + Send + Sync>> {
        let mut body = Vec::new();
        request
            .write_as_xml(&mut body)
            .expect("could not write request to buffer (this should never happen)");

        let response = build_headers(self.0, body.len() as u64)
            .body(body)
            .send()?;

        check_response(&response)?;

        Ok(response)
    }
} */

impl SumaClient {

    pub fn new(env: &str) -> SumaClient {
        // get config
        let toml_content = std::fs::read_to_string("./config/suma_default.toml").unwrap();
        let conf: Value = toml::from_str(&toml_content).unwrap();
        SumaClient{
            rpcurl: conf[env]["url"].as_str().unwrap().to_owned(),
            user:  conf[env]["user"].as_str().unwrap().to_owned(),
            pw: conf[env]["password"].as_str().unwrap().to_owned(),
            session: String::from("")
        }
    }

    fn open_session(&mut self) {
        let session_request = Request::new("auth.login").arg(self.user.as_str()).arg(self.pw.as_str()).call_url(self.rpcurl.as_str());
        self.session = session_request.unwrap().as_str().unwrap().to_owned();
    }

    fn close_session(&mut self) {
        // close session
        let _ = Request::new("auth.logout").arg(self.session.as_str()).call_url(self.rpcurl.as_str());
        println!("Session closed.");
    }
}



pub fn run_api() {

/*     let tp = SumaTransport(reqwest::blocking::Client::builder()
        .danger_accept_invalid_certs(true)
        .build()
        .unwrap()
        .post(RPCURL)); */

    let mut clt: SumaClient = SumaClient::new("default");
    clt.open_session();

    // let session_request = Request::new("auth.login").arg(USER).arg(PW).call_url(RPCURL);
    // let session_key: &str = &session_request.unwrap().as_str().unwrap().to_owned();
    // println!("Session opened with key {}", session_key);

    let vendor_channel_request = Request::new("channel.listVendorChannels").arg(clt.session.as_str()).call_url(clt.rpcurl.as_str()).unwrap();

    let vca = vendor_channel_request.as_array().unwrap();

    //14 days ago
    //let since = iso8601::datetime("2021-09-20T00:00:00+0100").unwrap();
    let since = iso8601::datetime(Utc::now().checked_sub_signed(Duration::days(14)).unwrap().to_rfc3339().as_str()).unwrap();
    //let since = Utc::now().checked_sub_signed(Duration::days(14)).unwrap().format("%FT00:00:00.0%z").to_string();
    //println!("{}", since);


    let mut suse_errata: HashMap<String, Errata> = HashMap::new();

    for vc in vca {
        let channel_errata = Request::new("channel.software.listErrata").arg(clt.session.as_str()).arg(vc["label"].as_str().unwrap()).arg(since).call_url(clt.rpcurl.as_str()).unwrap();
        for se in channel_errata.as_array().unwrap()  {
            let e: Errata = Errata {
                id:                 se["id"].as_i32().unwrap(),
                date:               se["date"].as_str().unwrap().to_owned(),
                update_date:        se["update_date"].as_str().unwrap().to_owned(),
                advisory_synopsis:  se["advisory_synopsis"].as_str().unwrap().to_owned(),
                advisory_type:      se["advisory_type"].as_str().unwrap().to_owned(),
                advisory_name:      se["advisory_name"].as_str().unwrap().to_owned(),
            };

            suse_errata.insert(se["advisory_name"].as_str().unwrap().to_owned(), e.to_owned());
        }
    }

    //println!("Errata HashMap: {:?}", suse_errata);
    let mut cve_list: BTreeMap<String, CVE> = BTreeMap::new();

    // find the CVEs
    // errata.listCves
    for (en, er) in suse_errata.iter() {
        let cves = Request::new("errata.listCves").arg(clt.session.as_str()).arg(en.as_str()).call_url(clt.rpcurl.as_str()).unwrap();
        for cve in cves.as_array().unwrap() {
            let cve_str = cve.as_str().unwrap();
            // check if the CVE is already on the list
            if !cve_list.contains_key(cve_str) {
                let c: CVE = CVE {
                    cve_id:             cve_str.to_owned(),
                    suse_errata_list:   vec![er.to_owned()],
                };
                cve_list.insert(cve_str.to_owned(), c.to_owned());
            } else {
                // we know there is a cve already logged
                // just add the existing errata to the vector
                let c2 = cve_list.get_mut(cve_str).unwrap();
                c2.add_errata(er);
                
            }
        }
    }

    let _e = persistence::batch_insert("NEW", cve_list.clone(), None);

    //println!("Processed cve list {:?}", cve_list);

    // encode CVE List to JSON
     let j = serde_json::to_string(&cve_list);
    // save_json(j.unwrap().to_owned(), "static/suse_cves.json");
    // println!("Json is {:}", j.unwrap());
    // // output CVE List to JSON
    produce_json(&cve_list);

    clt.close_session();
}

fn produce_json(list: &BTreeMap<String, CVE>) {
    // cve list flat
    let mut cve_list_flat = Vec::new();

    // loop over provided hash map
    for (key, rec) in list.iter() {
        for el in rec.suse_errata_list.iter() {
            let tmp_cve: CveJson = CveJson {
                cve_id:             key.to_owned(),
                date:               el.date.to_owned(),
                update_date:        el.update_date.to_owned(),
                advisory_synopsis:  el.advisory_synopsis.to_owned(),
                advisory_type:      el.advisory_type.to_owned(),
                advisory_name:      el.advisory_name.to_owned(),
            };
            cve_list_flat.push(tmp_cve.to_owned())
        }
    } 

    let j = serde_json::to_string(&cve_list_flat).unwrap();
    println!{"JSON\n{}", j};
    //save_json(j, "static/suse_cves.json");
}

fn save_json(j: String, p: &str) {
    println!("Json is {:}", j);
    // output CVE List to JSON
    let path = Path::new(p);
    let mut file = match File::create(&path) {
        Err(why) => panic!("Could not create {}: {}", path.display(), why),
        Ok(file) => file,
    };

    match file.write_all(j.to_owned().as_bytes()) {
        Err(why) => panic!("Could not write to {}: {}", path.display(), why),
        Ok(_) => println!("Successfully wrote to {}", path.display()),
    }
}