// component to refresh/update the data
use yew::prelude::*;
use std::rc::Rc;
use yew_hooks::use_async;

// reducer's Action
enum UpdateAction {
    Update
}

/// reducer's State
struct CounterState {
    counter: i32,
}

impl Default for CounterState {
    fn default() -> Self {
        Self { counter: 1 }
    }
}

impl Reducible for CounterState {
    /// Reducer Action Type
    type Action = UpdateAction;

    /// Reducer Function
    fn reduce(self: Rc<Self>, _action: Self::Action) -> Rc<Self> {
        let next_ctr = self.counter + 1;

        let state = use_async(async move{
            api_call().await
        });

        state.run();

        Self { counter: next_ctr }.into()
    }
}

#[function_component(UseReducer)]
pub fn reducer() -> Html {
    // The use_reducer hook takes an initialization function which will be called only once.
   let counter = use_reducer(CounterState::default);

   let update_onclick = {
       let counter = counter.clone();
       Callback::from(move |_| counter.dispatch(UpdateAction::Update))
    };

    html! {
        <div class="btn-group me-2">
            <button type="button" class="btn btn-sm btn-outline-secondary" onclick={update_onclick}>{"Update Data"}</button>
            
            <div id="result">{ counter.counter }</div>  
        </div>
    }
}

async fn api_call() -> Result<String, String> {
    match reqwest::get("http://localhost:8081/api/updator").await {
        Ok(_) => Ok(String::from("Ok")),
        Err(_) => Err(String::from("NOK")),
    }
}