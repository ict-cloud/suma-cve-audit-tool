use crate::persistence::rdbms::open_pool;
use crate::persistence::rdbms::open_pool;
use crate::persistence::utils::convert_jd;
use cve_audit_types::*;
use futures::TryStreamExt;
use serde_json;
use sqlx::{Result, Row};
use serde_json;
use sqlx::{Result, Row};

pub async fn errata_get_audit_trail(i_errata_id: u32) -> Vec<ErrataAuditData> {
    let mut aud_trail: Vec<ErrataAuditData> = Vec::new();

    let sel = r#"
    select * from (
        select  id as audit_id,
                errata_id,
                audit_date,
                auditor,
                responsible,
                status,
                assessment,
                assess_score,
                assessment_comment
        from    audit_data
        where   errata_id = ?1
        union 
        select  audit_id,
                errata_id,
                audit_date,
                auditor,
                responsible,
                status,
                assessment,
                assess_score,
                assessment_comment
        from    audit_trail
        where   errata_id = ?1
    ) order by audit_date desc;"#;

    let mut rows = sqlx::query(sel).bind(i_errata_id).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        let tmp = ErrataAuditData  {
            id: row.try_get(0).unwrap(),
            errata_id: row.try_get(1).unwrap(),
            audit_date: convert_jd(row.try_get(2).unwrap()),
            auditor: row.try_get(3).unwrap(),
            resp: row.try_get(4).unwrap(),
            status: serde_json::from_str(row.try_get(5).unwrap()).unwrap(),
            assessment_verdict: serde_json::from_str(row.try_get(6).unwrap()).unwrap(),
            assessed_score: row.try_get(7).unwrap(),
            assessment_comment: row.try_get(8).unwrap(),,
        };

        aud_trail.push(tmp);
    }

    aud_trail
}

pub async fn get_audit_for_errata(i_errata_id: u32) -> ErrataAuditData {

    let sel = r#"
      select * from audit_data where errata_id = ?
    "#;
    let conn = open_pool();

    let rows = sqlx::query(sel)
        .bind(i_errata_id)
        .fetch_optional(&conn).await.unwrap();
    let ead: ErrataAuditData = if let Some(row) = rows {
        ErrataAuditData{
            id: row.try_get(0).unwrap(),
            errata_id: row.try_get(1).unwrap(),
            audit_date: convert_jd(row.try_get(2).unwrap()),
            auditor: row.try_get(3).unwrap(),
            resp: row.try_get(4).unwrap(),
            status: serde_json::from_str(row.try_get(5).unwrap()).unwrap(),
            assessment_verdict: serde_json::from_str(row.try_get(6).unwrap()).unwrap(),
            assessed_score: row.try_get(7).unwrap(),
            assessment_comment: row.try_get(8).unwrap()
        }
      } else {
        ErrataAuditData::default()
    };
    ead
}

pub async fn write_audit_data(i_ad: ErrataAuditData) -> Result<()> {
    //log::debug!("Form data for writing received {:?}", i_ad);

    // CREATE TABLE IF NOT EXISTS audit_data (
    //     id integer primary key,
    //     errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
    //     audit_date REAL NOT NULL,
    //     auditor TEXT,
    //     responsible TEXT,
    //     status TEXT NOT NULL,
    //     assessment TEXT NOT NULL,
    //     assess_score REAL,
    //     assessment_comment TEXT
    // );

    // batch execute
    // first insert legacy record to audit trail
    // second delete legqcy records
    // insert new record

    let mov_stmt = r#"
        insert into audit_trail 
        select * 
        from   audit_data
        where  errata_id = ?;
    "#;

    let mov = sqlx::query(mov_stmt)
        .bind(&i_ad.errata_id)
        .execute(&open_pool())
        .await;

    match mov {
        Ok(r) => log::info!("Successfully moved {:?}", r),
        Err(e) => log::error!("Error during move of audit_data: {}", e),
    };

    let rem_stmt = r#"delete from audit_data where errata_id = ?"#;

    let rem = sqlx::query(rem_stmt)
        .bind(&i_ad.errata_id)
        .execute(&open_pool())
        .await;

    match rem {
        Ok(r) => log::info!("Successfully removed {:?}", r),
        Err(e) => log::error!("Error during delete of audit_data: {}", e),
    };

    let stmt = r#"insert into audit_data (
        errata_id,
        auditor,
        responsible,
        status,
        assessment,
        assess_score,
        assessment_comment,
        audit_date
        ) VALUES 
        (?1, ?2, ?3, ?4, ?5, ?6, ?7, julianday('now'));"#;

    let ins = sqlx::query(stmt)
        .bind(&i_ad.errata_id)
        .bind(&i_ad.auditor)
        .bind(&i_ad.resp)
        .bind(serde_json::to_string(&i_ad.status).unwrap_or_default())
        .bind(serde_json::to_string(&i_ad.assessment_verdict).unwrap_or_default())
        .bind(&i_ad.assessed_score)
        .bind(&i_ad.assessment_comment)
        .execute(&open_pool())
        .await;

    match ins {
        Ok(r) => log::info!("Successfully inserted {:?}", r),
        Err(e) => log::error!("Error during insert of audit_data: {}", e),
    };

    Ok(())
}