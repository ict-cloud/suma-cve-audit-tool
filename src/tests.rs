#[cfg(test)]
use cve_audit_types::*;
use crate::persistence::rdbms;
use std::collections::HashMap;

#[test]
fn sql_demo_data() {
    let rt = tokio::runtime::Runtime::new().unwrap();

    let _ok = rdbms::setup();
    // add some code to add demo data
    let mut errata:Vec<ErrataExtended> = Vec::new();
    // first some errata
    let mut nr = 10;
    while nr < 20 {
        let e = ErrataExtended{
            id: nr 
           ,date: format!("2022-01-{}", nr)
           ,update_date: format!("2022-01-{}", nr).to_owned()
           ,advisory_synopsis: String::from("This is a synopsis which is a longer text")
           ,advisory_type: String::from("Security")
           ,advisory_name: format!("advisory-{}", nr).to_owned()
           ,cves: Vec::new()
           ,sys_affected: false,
        };
        errata.push(e.to_owned());
        nr += 1;
    }
    
    // CVES
    let mut cves: Vec<String> = Vec::new();
    let mut nr = 100;
    while nr < 105 {
        cves.push(format!("CVE-2022-{}", nr).to_owned());
        nr += 1;
    }

    let mut ee_list: Vec<ErrataExtended> = Vec::new();
    // dummy hash map
    let sys_cnt: HashMap<String, i32> = HashMap::new();

    for e in errata.iter() {
        let mut ee = ErrataExtended::from(e.to_owned());
        ee.cves = cves.clone();
        ee_list.push(ee);
    }

    let async_store = async move { rdbms::batch_store(ee_list, sys_cnt).await};
    let ok = rt.block_on(async_store);
    assert_eq!(ok, std::result::Result::Ok(()));

    // fetch the result
    
    let ee = async move {rdbms::get_errataext().await};
    let ee_res = rt.block_on(ee);

    assert_eq!(10, ee_res.len());

}