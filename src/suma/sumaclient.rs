extern crate xmlrpc;
extern crate iso8601;

use xmlrpc::{Request};
use std::collections::{HashMap};
use serde_derive::{Deserialize, Serialize};
use chrono::{Duration, Utc};
use toml::Value;
use cve_audit_types::*;
use crate::persistence::rdbms;


#[derive(Debug, Clone, Serialize, Deserialize)]
struct CveJson {
    cve_id: String, 
    date: String,
    update_date: String,
    advisory_synopsis: String,
    advisory_type: String,
    advisory_name: String,
}

#[derive(Debug)]
struct SumaClient {
    rpcurl: String,
    user: String,
    pw: String,
    session: String,
}

impl SumaClient {

    pub fn new(env: &str) -> SumaClient {
        let dir = std::env::current_exe().unwrap().parent().expect("Executable must be in some directory").to_owned();
        let mut path = dir.join("config").to_owned();
        path.push("suma.toml");
        // get config
        let toml_content = std::fs::read_to_string(path).unwrap();
        let conf: Value = toml::from_str(&toml_content).unwrap();
        SumaClient{
            rpcurl: conf[env]["url"].as_str().unwrap().to_owned(),
            user:  conf[env]["user"].as_str().unwrap().to_owned(),
            pw: conf[env]["password"].as_str().unwrap().to_owned(),
            session: String::from("")
        }
    }

    fn open_session(&mut self) {
        let session_request = Request::new("auth.login").arg(self.user.as_str()).arg(self.pw.as_str()).call_url(self.rpcurl.as_str());
        match session_request {
            Ok(val) => { self.session = val.as_str().unwrap().to_owned(); log::info!("No problem")},
            Err(e)  => log::error!("open_session error {}", e)
        };
    }

    fn close_session(&mut self) {
        // close session
        match Request::new("auth.logout").arg(self.session.as_str()).call_url(self.rpcurl.as_str()) {
            Ok(_value) => log::info!("Session closed"),
            Err(error) => log::error!("Error during closing of session {}", error),
        }
    }
}



pub fn run_api() -> Result<(), Box<dyn std::error::Error>> {

    let mut clt: SumaClient = SumaClient::new("default");
    clt.open_session();

    fetch_errata(&clt);

    clt.close_session();
    Ok(())
}

fn fetch_errata(suma_clt: &SumaClient) {
    let vendor_channel_request = 
      match Request::new("channel.listVendorChannels").arg(suma_clt.session.as_str()).call_url(suma_clt.rpcurl.as_str()) {
          Ok(res) => res.as_array().unwrap().to_owned(),
          Err(_)  => Vec::new(),
      };

    //14 days ago
    let since = iso8601::datetime(Utc::now().checked_sub_signed(Duration::days(14)).unwrap().to_rfc3339().as_str()).unwrap();

    let mut suse_errata: HashMap<String, Errata> = HashMap::new();
    let mut cve_systems: HashMap<String, i32> = HashMap::new();

    for vc in vendor_channel_request {
        let channel_errata = Request::new("channel.software.listErrata").arg(suma_clt.session.as_str()).arg(vc["label"].as_str().unwrap()).arg(since).call_url(suma_clt.rpcurl.as_str()).unwrap();
        for se in channel_errata.as_array().unwrap()  {
            let e: Errata = Errata {
                id:                 se["id"].as_i32().unwrap(),
                date:               se["date"].as_str().unwrap().to_owned(),
                update_date:        se["update_date"].as_str().unwrap().to_owned(),
                advisory_synopsis:  se["advisory_synopsis"].as_str().unwrap().to_owned(),
                advisory_type:      se["advisory_type"].as_str().unwrap().to_owned(),
                advisory_name:      se["advisory_name"].as_str().unwrap().to_owned(),
            };

            suse_errata.insert(se["advisory_name"].as_str().unwrap().to_owned(), e.to_owned());
        }
    }

    // find the CVEs
    for (en, er) in suse_errata.iter() {
        // first store the errata
        // match rdbms::store_errata(er) {
        //     Ok(()) => log::info!("Errata stored"),
        //     Err(e) => log::error!("sumaclient fetch_errata error occured {}", e),
        // };
        let cves_resp = Request::new("errata.listCves").arg(suma_clt.session.as_str()).arg(en.as_str()).call_url(suma_clt.rpcurl.as_str()).unwrap();

        // convert errata to ErrataExtended
        let mut ee = ErrataExtended::from(er.clone());

        // check if the systems are affected
        // the CVE can be in multiple errata and thus we should have a map/BT to look up if one CVE has already been requested from the UI

        // bad code leading to O(n2)
        // better solution
        // merge the cves_resp.as_array into the ee.cves
        // merge into another array (or probably hash map?)
        // update and store the CVE count afterwards
        for cve in cves_resp.as_array().unwrap() {
            let cve_str = cve.as_str().unwrap().to_owned();
            // ee.cves.append(...);
            ee.cves.push(cve_str.to_owned());
            // cve is only once queried to the SUMA otherwise read from HashMap
            let syscnt = match cve_systems.get(cve_str.as_str()) {
                Some(cnt) => cnt.to_owned(),
                None => cve_syscount(&cve_str, &mut cve_systems, suma_clt)
            };
            // once the sys_affected is set, we do not revert it, otherwise check if it might have changed
            if !ee.sys_affected { ee.sys_affected = syscnt >= 1; }
            
            // insert to database if any system is affected
            rdbms::store_cve_affsystem(cve.as_str().unwrap(), syscnt).unwrap();
        }
        // insert errstore_eeded
        match rdbms::store_ee(&ee) {
            Ok(()) => log::info!("CVE successfully stored"),
            Err(e) => log::error!("sumaclient fetch errata error occured {}", e),
        };
    }
}

// lazy loading method to query the suse manager api and amend the hash map
fn cve_syscount(i_cve: &str, x_cve_systems: &mut HashMap<String, i32>, suma_clt: &SumaClient) -> i32 {
    
    let sel_val = xmlrpc::Value::Array(vec![xmlrpc::Value::from("AFFECTED_PATCH_INAPPLICABLE"), xmlrpc::Value::from("AFFECTED_PATCH_APPLICABLE")]);
    let cve_audit_resp = Request::new("audit.listSystemsByPatchStatus")
                                    .arg(suma_clt.session.as_str())
                                    .arg(i_cve)
                                    .arg(sel_val.clone())
                                    .call_url(suma_clt.rpcurl.as_str()).unwrap();
    let numsys = cve_audit_resp.as_array().unwrap().len();
    let cnt = i32::try_from(numsys).unwrap_or_default();

    x_cve_systems.insert(i_cve.to_owned(), cnt.to_owned());
    cnt
}