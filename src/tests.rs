use crate::persistence::*;
#[cfg(test)]
use cve_audit_types::*;
use std::collections::HashMap;

#[test]
fn sql_demo_data() {
    let rt = tokio::runtime::Runtime::new().unwrap();

    let setup = async { rdbms_init::setup().await };
    let setup_res = match rt.block_on(setup) {
        Ok(_) => true,
        Err(_) => false,
    };
    assert!(setup_res);

    // add some code to add demo data
    let mut errata: Vec<ErrataExtended> = Vec::new();
    // first some errata
    let mut nr = 10;
    while nr < 20 {
        let e = ErrataExtended {
            id: nr,
            date: format!("2022-01-{}", nr),
            update_date: format!("2022-01-{}", nr).to_owned(),
            advisory_synopsis: String::from("This is a synopsis which is a longer text"),
            advisory_type: String::from("Security"),
            advisory_name: format!("advisory-{}", nr).to_owned(),
            cves: Vec::new(),
            sys_affected: false,
        };
        errata.push(e.to_owned());
        nr += 1;
    }

    // CVES
    let mut cves: Vec<String> = Vec::new();
    let mut nr = 100;
    while nr < 105 {
        cves.push(format!("CVE-2022-{}", nr).to_owned());
        nr += 1;
    }

    let mut ee_list: Vec<ErrataExtended> = Vec::new();
    // dummy hash map
    let sys_cnt: HashMap<String, i32> = HashMap::new();

    for e in errata.iter() {
        let mut ee = ErrataExtended::from(e.to_owned());
        ee.cves = cves.clone();
        ee_list.push(ee);
    }

    let async_store = async move { rdbms::batch_store(ee_list, sys_cnt).await };
    let ok = match rt.block_on(async_store) {
        Ok(_) => true,
        Err(_) => false,
    };
    assert!(ok);

    // fetch the result

    let ee = async move { rdbms::get_errataext().await };
    let ee_res = rt.block_on(ee);

    assert_eq!(10, ee_res.len());
}
