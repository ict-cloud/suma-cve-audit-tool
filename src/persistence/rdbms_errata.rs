use sqlx::{Row};
use cve_audit_types::*;
use crate::persistence::rdbms::open_pool;
use futures::TryStreamExt;
use crate::persistence::utils::*;

pub async fn list_errata_with_audit() -> Vec<ErrataWithAudit> {
    let mut ewa: Vec<ErrataWithAudit> = Vec::new();

    // one big query, create the structure afterwards
    // cve list as CSV
    let sel = r#"
        with cve_err as (
            select errata_id
                  ,group_concat(cve_id) as cves
            from errata_cve
            group by errata_id
        )
        select e.suse_id
			,e.date
			,e.advisory_name
			,e.advisory_synopsis
            ,ad.id
            ,ad.audit_date
            ,ad.auditor
            ,ad.responsible
            ,ad.status
            ,ad.assessment
            ,ad.assess_score
            ,ad.assessment_comment
            ,ce.cves
        from errata e
            ,audit_data ad
        left join cve_err ce on ce.errata_id = e.suse_id
        where ad.errata_id = e.suse_id
        ;
    "#;

    let mut rows = sqlx::query(sel).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        // try to process the csv to vec<String>
        let cves_raw: &str = row.try_get(12).unwrap();
        let cve_vec: Vec<String> = to_vec_string(cves_raw).to_owned();
        let ead: ErrataAuditData = ErrataAuditData {
            id: row.try_get(4).unwrap(),
            errata_id: row.try_get(0).unwrap(),
            audit_date: convert_jd(row.try_get(5).unwrap()),
            auditor: row.try_get(6).unwrap(),
            resp: row.try_get(7).unwrap(),
            status: serde_json::from_str(row.try_get(8).unwrap()).expect("Valid AuditStatus expected"),
            assessment_verdict: serde_json::from_str(row.try_get(9).unwrap()).expect("Valid AuditAssessment expected"),
            assessed_score: row.try_get(10).unwrap(),
            assessment_comment: row.try_get(11).unwrap(),
        };
        // the temp record to push on the vector later
        let tmp: ErrataWithAudit = ErrataWithAudit{
            id: ead.errata_id,
            date: convert_jd(row.try_get(1).unwrap()),
            advisory_name: row.try_get(2).unwrap(),
            advisory_synopsis: row.try_get(3).unwrap(),
            cves: cve_vec.to_owned(),
            audit_data: ead.to_owned(),
        };
        ewa.push(tmp.to_owned());
    }
    ewa
}