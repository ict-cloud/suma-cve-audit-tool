extern crate xmlrpc;
extern crate iso8601;

use xmlrpc::{Request};
use std::collections::{HashMap, BTreeMap};
use serde_derive::{Deserialize, Serialize};
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;
use chrono::{Duration, Utc};
use toml::Value;
use cve_audit_types::*;
use crate::persistence::{keyval, rdbms};


#[derive(Debug, Clone, Serialize, Deserialize)]
struct CveJson {
    cve_id: String, 
    date: String,
    update_date: String,
    advisory_synopsis: String,
    advisory_type: String,
    advisory_name: String,
}

#[derive(Debug)]
struct SumaClient {
    rpcurl: String,
    user: String,
    pw: String,
    session: String,
}

/* /// Custom transport that adds a cookie header.
struct SumaTransport(RequestBuilder);

impl Transport for SumaTransport {
    type Stream = Response;

    fn transmit(self, request: &Request) -> Result<Self::Stream, Box<dyn Error + Send + Sync>> {
        let mut body = Vec::new();
        request
            .write_as_xml(&mut body)
            .expect("could not write request to buffer (this should never happen)");

        let response = build_headers(self.0, body.len() as u64)
            .body(body)
            .send()?;

        check_response(&response)?;

        Ok(response)
    }
} */

impl SumaClient {

    pub fn new(env: &str) -> SumaClient {
        let dir = std::env::current_exe().unwrap().parent().expect("Executable must be in some directory").to_owned();
        let mut path = dir.join("config").to_owned();
        path.push("suma.toml");
        // get config
        let toml_content = std::fs::read_to_string(path).unwrap();
        //let toml_content = std::fs::read_to_string("./config/suma.toml").unwrap();
        let conf: Value = toml::from_str(&toml_content).unwrap();
        SumaClient{
            rpcurl: conf[env]["url"].as_str().unwrap().to_owned(),
            user:  conf[env]["user"].as_str().unwrap().to_owned(),
            pw: conf[env]["password"].as_str().unwrap().to_owned(),
            session: String::from("")
        }
    }

    fn open_session(&mut self) {
        let session_request = Request::new("auth.login").arg(self.user.as_str()).arg(self.pw.as_str()).call_url(self.rpcurl.as_str());
        match session_request {
            Ok(val) => { self.session = val.as_str().unwrap().to_owned(); log::info!("No problem")},
            Err(e)  => log::error!("open_session error {}", e)
        };
    }

    fn close_session(&mut self) {
        // close session
        match Request::new("auth.logout").arg(self.session.as_str()).call_url(self.rpcurl.as_str()) {
            Ok(_value) => log::info!("Session closed"),
            Err(error) => log::error!("Error during closing of session {}", error),
        }
    }
}



pub fn run_api() -> Result<(), Box<dyn std::error::Error>> {

/*     let tp = SumaTransport(reqwest::blocking::Client::builder()
        .danger_accept_invalid_certs(true)
        .build()
        .unwrap()
        .post(RPCURL)); */

    let mut clt: SumaClient = SumaClient::new("default");
    clt.open_session();

    //fetch_cves(&clt);
    fetch_errata(&clt);

    // let session_request = Request::new("auth.login").arg(USER).arg(PW).call_url(RPCURL);
    // let session_key: &str = &session_request.unwrap().as_str().unwrap().to_owned();
    // println!("Session opened with key {}", session_key);

    clt.close_session();
    Ok(())
}

fn fetch_cves(suma_clt: &SumaClient) {
    let vendor_channel_request = 
      match Request::new("channel.listVendorChannels").arg(suma_clt.session.as_str()).call_url(suma_clt.rpcurl.as_str()) {
          Ok(res) => res.as_array().unwrap().to_owned(),
          Err(_)  => Vec::new(),
      };

    //let vca = vendor_channel_request.as_array().unwrap();

    //14 days ago
    //let since = iso8601::datetime("2021-09-20T00:00:00+0100").unwrap();
    let since = iso8601::datetime(Utc::now().checked_sub_signed(Duration::days(14)).unwrap().to_rfc3339().as_str()).unwrap();
    //let since = Utc::now().checked_sub_signed(Duration::days(14)).unwrap().format("%FT00:00:00.0%z").to_string();
    //println!("{}", since);


    let mut suse_errata: HashMap<String, Errata> = HashMap::new();

    for vc in vendor_channel_request {
        let channel_errata = Request::new("channel.software.listErrata").arg(suma_clt.session.as_str()).arg(vc["label"].as_str().unwrap()).arg(since).call_url(suma_clt.rpcurl.as_str()).unwrap();
        for se in channel_errata.as_array().unwrap()  {
            let e: Errata = Errata {
                id:                 se["id"].as_i32().unwrap(),
                date:               se["date"].as_str().unwrap().to_owned(),
                update_date:        se["update_date"].as_str().unwrap().to_owned(),
                advisory_synopsis:  se["advisory_synopsis"].as_str().unwrap().to_owned(),
                advisory_type:      se["advisory_type"].as_str().unwrap().to_owned(),
                advisory_name:      se["advisory_name"].as_str().unwrap().to_owned(),
            };

            suse_errata.insert(se["advisory_name"].as_str().unwrap().to_owned(), e.to_owned());
        }
    }

    //println!("Errata HashMap: {:?}", suse_errata);
    let mut cve_list: BTreeMap<String, CVE> = BTreeMap::new();

    // find the CVEs
    // errata.listCves
    for (en, er) in suse_errata.iter() {
        let cves = Request::new("errata.listCves").arg(suma_clt.session.as_str()).arg(en.as_str()).call_url(suma_clt.rpcurl.as_str()).unwrap();
        for cve in cves.as_array().unwrap() {
            let cve_str = cve.as_str().unwrap();
            // check if the CVE is already on the list
            if !cve_list.contains_key(cve_str) {
                let c: CVE = CVE {
                    cve_id:             cve_str.to_owned(),
                    suse_errata_list:   vec![er.to_owned()],
                };
                cve_list.insert(cve_str.to_owned(), c.to_owned());
            } else {
                // we know there is a cve already logged
                // just add the existing errata to the vector
                let c2 = cve_list.get_mut(cve_str).unwrap();
                c2.add_errata(er);
                
            }
        }
    }

    let _e = keyval::batch_insert("NEW", cve_list.clone(), None);

    //println!("Processed cve list {:?}", cve_list);

    // encode CVE List to JSON
    let j = serde_json::to_string(&cve_list);
    // save_json(j.unwrap().to_owned(), "static/suse_cves.json");
    // println!("Json is {:}", j.unwrap());
    // // output CVE List to JSON
    produce_json(&cve_list);
}

fn produce_json(list: &BTreeMap<String, CVE>) {
    // cve list flat
    let mut cve_list_flat = Vec::new();

    // loop over provided hash map
    for (key, rec) in list.iter() {
        for el in rec.suse_errata_list.iter() {
            let tmp_cve: CveJson = CveJson {
                cve_id:             key.to_owned(),
                date:               el.date.to_owned(),
                update_date:        el.update_date.to_owned(),
                advisory_synopsis:  el.advisory_synopsis.to_owned(),
                advisory_type:      el.advisory_type.to_owned(),
                advisory_name:      el.advisory_name.to_owned(),
            };
            cve_list_flat.push(tmp_cve.to_owned())
        }
    } 

    //let j = serde_json::to_string(&cve_list_flat).unwrap();
    //println!{"JSON\n{}", j};
    //save_json(j, "static/suse_cves.json");
}

fn save_json(j: String, p: &str) {
    // output CVE List to JSON
    let path = Path::new(p);
    let mut file = match File::create(&path) {
        Err(why) => panic!("Could not create {}: {}", path.display(), why),
        Ok(file) => file,
    };

    match file.write_all(j.to_owned().as_bytes()) {
        Err(why) => panic!("Could not write to {}: {}", path.display(), why),
        Ok(_) => println!("Successfully wrote to {}", path.display()),
    }
}

fn fetch_errata(suma_clt: &SumaClient) {
    let vendor_channel_request = 
      match Request::new("channel.listVendorChannels").arg(suma_clt.session.as_str()).call_url(suma_clt.rpcurl.as_str()) {
          Ok(res) => res.as_array().unwrap().to_owned(),
          Err(_)  => Vec::new(),
      };

    //let vca = vendor_channel_request.as_array().unwrap();

    //14 days ago
    //let since = iso8601::datetime("2021-09-20T00:00:00+0100").unwrap();
    let since = iso8601::datetime(Utc::now().checked_sub_signed(Duration::days(14)).unwrap().to_rfc3339().as_str()).unwrap();
    //let since = Utc::now().checked_sub_signed(Duration::days(14)).unwrap().format("%FT00:00:00.0%z").to_string();
    //println!("{}", since);


    let mut suse_errata: HashMap<String, Errata> = HashMap::new();

    for vc in vendor_channel_request {
        let channel_errata = Request::new("channel.software.listErrata").arg(suma_clt.session.as_str()).arg(vc["label"].as_str().unwrap()).arg(since).call_url(suma_clt.rpcurl.as_str()).unwrap();
        for se in channel_errata.as_array().unwrap()  {
            let e: Errata = Errata {
                id:                 se["id"].as_i32().unwrap(),
                date:               se["date"].as_str().unwrap().to_owned(),
                update_date:        se["update_date"].as_str().unwrap().to_owned(),
                advisory_synopsis:  se["advisory_synopsis"].as_str().unwrap().to_owned(),
                advisory_type:      se["advisory_type"].as_str().unwrap().to_owned(),
                advisory_name:      se["advisory_name"].as_str().unwrap().to_owned(),
            };

            suse_errata.insert(se["advisory_name"].as_str().unwrap().to_owned(), e.to_owned());
        }
    }

    //println!("Errata HashMap: {:?}", suse_errata);
    //let mut cve_list: BTreeMap<String, CVE> = BTreeMap::new();

    // find the CVEs
    // errata.listCves
    for (en, er) in suse_errata.iter() {
        // first store the errata
        match rdbms::store_errata(er) {
            Ok(()) => log::info!("Errata stored"),
            Err(e) => log::error!("sumaclient fetch_errata error occured {}", e),
        };
        let cves_resp = Request::new("errata.listCves").arg(suma_clt.session.as_str()).arg(en.as_str()).call_url(suma_clt.rpcurl.as_str()).unwrap();

        // convert errata to ErrataExtended
        let mut ee = ErrataExtended::from(er.clone());
        let sel_val = xmlrpc::Value::Array(vec![xmlrpc::Value::from("AFFECTED_PATCH_INAPPLICABLE"), xmlrpc::Value::from("AFFECTED_PATCH_APPLICABLE")]);

        // check if the systems are affected
        for cve in cves_resp.as_array().unwrap() {
            ee.cves.push(cve.as_str().unwrap().to_owned());
            //if cve.as_str().unwrap() == "CVE-2021-3997" {
            //println!("Auditing check for CVE {}", cve.as_str().unwrap());
            let cve_audit_resp = Request::new("audit.listSystemsByPatchStatus")
                                    .arg(suma_clt.session.as_str())
                                    .arg(cve.as_str())
                                    .arg(sel_val.clone())
                                    .call_url(suma_clt.rpcurl.as_str()).unwrap();
            let numsys = cve_audit_resp.as_array().unwrap().len();
            // once the sys_affected is set, we do not revert it, otherwise check if it might have changed
            if !ee.sys_affected { ee.sys_affected = numsys > 1; }
            //println!("Response {:?}", cve_audit_resp.as_array().unwrap().len());
            //}
            // insert to database if any system is affected
            rdbms::store_cve_affsystem(cve.as_str().unwrap(), i32::try_from(numsys).unwrap_or_default()).unwrap();
        }
        // insert errata extended
        match rdbms::store_cve(&ee) {
            Ok(()) => log::info!("CVE successfully stored"),
            Err(e) => log::error!("sumaclient fetch errata error occured {}", e),
        };

        // set the affected system flag if counter is > 0

        // match rdbms::store_cve(&ee) {
        //     Ok(()) => log::info!("CVE successfully stored"),
        //     Err(e) => log::error!("sumaclient fetch errata error occured {}", e),
        // };
    }
}