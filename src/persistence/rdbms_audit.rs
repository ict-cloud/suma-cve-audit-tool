use crate::persistence::utils::convert_jd;
use crate::persistence::rdbms::open_pool;
use cve_audit_types::*;
use sqlx::{Row, Result, sqlite::SqlitePool};
//use futures::TryStreamExt;

pub async fn get_audit_for_errata(i_errata_id: u32) -> ErrataAuditData {
    
    //let mut ere: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let sel = r#"
      select * from audit_data where errata_id = ? order by update_date desc
    "#;
    let conn = open_pool();

    let rows = sqlx::query(sel)
        .bind(i_errata_id)
        .fetch_optional(&conn).await.unwrap();
    let ead: ErrataAuditData = if let Some(row) = rows {
        //let r = row.unwrap();
        ErrataAuditData{
            id: row.try_get(0).unwrap(),
            errata_id: row.try_get(1).unwrap(),
            audit_date: row.try_get(2).unwrap(),
            auditor: row.try_get(3).unwrap(),
            resp: row.try_get(4).unwrap(),
            status: AuditStatus::New, //row.try_get(5).unwrap(),
            assessment_verdict: AuditAssessment::Unclear, //row.try_get(6).unwrap(),
            assessed_score: row.try_get(7).unwrap(),
            assessment_comment: row.try_get(8).unwrap()
        }
      } else {
        ErrataAuditData{
            id: 0,
            errata_id: 0,
            audit_date: String::from(""),
            auditor: String::from(""),
            resp: String::from(""),
            status: AuditStatus::New,
            assessment_verdict: AuditAssessment::Unclear,
            assessed_score: 0.0,
            assessment_comment: String::from("")
        }
    };

    ead
}