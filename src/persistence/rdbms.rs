use crate::persistence::utils::*;
use futures::TryStreamExt;
use once_cell::sync::OnceCell;
use sqlx::{sqlite::SqlitePool, Result, Row};
use std::collections::HashMap;
use tokio::runtime::Runtime;

// Constants
pub const DB_NAME: &str = "suse_errata.sqlite";
const POOL: OnceCell<SqlitePool> = OnceCell::new();

// ENUM
#[derive(Debug, PartialEq)]
pub enum SecAdvisoryKind {
    Affected,
    AffectedUnrated,
    Unaffected,
}

/*  SETUP of Relational database
* suse_errata
*    data from suse errata
*
*  CVE
*    data for CVE (id, name, score)
*
*  Audit Evaluation
*    Data of the evaluation
*    date, person, result,
*
*  errata_cve
*    Relations from errata to cve
*
*  errata_audit
*    Relations from errata to audits
*
*  cve_systems
*    systems affected by cve
*/

pub fn open_pool() -> SqlitePool {
    match POOL.get() {
        Some(p) => p.to_owned(),
        None => init_pool().to_owned(),
    }
}

fn init_pool() -> SqlitePool {
    let dir = std::env::current_exe()
        .unwrap()
        .parent()
        .expect("Executable must be in some directory")
        .to_owned();
    let mut path = dir.join("db");
    path.push(DB_NAME);

    let async_pool = async move { SqlitePool::connect(path.to_str().unwrap()).await };

    let pool_thread = std::thread::spawn(|| Runtime::new().unwrap().block_on(async_pool))
        .join()
        .unwrap();

    let p = POOL.get_or_try_init(|| pool_thread).unwrap().to_owned();

    p
}

// current path
pub fn db_path() -> String {
    let dir = std::env::current_exe()
        .unwrap()
        .parent()
        .expect("Executable must be in some directory")
        .to_owned();
    let path = dir.join("db");

    // return path string
    path.to_str().unwrap().to_owned()
}

pub async fn batch_store(
    i_errata_list: Vec<cve_audit_types::ErrataExtended>,
    i_syscnt_list: HashMap<String, i32>,
) -> Result<()> {
    let conn = open_pool();
    for errata in i_errata_list {
        match store_ee(&errata, &conn).await {
            Ok(()) => log::info!("rdbms errata stored"),
            Err(e) => log::error!("error during rdbms::batch_store {}", e),
        }
    }

    for (cve, cnt) in i_syscnt_list {
        match store_cve_affsystem(&cve, cnt, &conn).await {
            Ok(()) => log::info!("rdbms::batch_store affected system stored"),
            Err(e) => log::error!("error during rdbms::batch_store::i_syscnt_list {}", e),
        }
    }
    Ok(())
}

async fn store_ee(
    i_errata_ext: &cve_audit_types::ErrataExtended,
    i_pool: &SqlitePool,
) -> Result<()> {
    //let conn = open_db();
    let stmt_errata = r#"INSERT INTO errata VALUES (?1, julianday(?2), julianday(?3), ?4, ?5, ?6) ON CONFLICT DO NOTHING"#;
    let stmt_cve = r#"INSERT INTO cve (id) VALUES (?) ON CONFLICT (id) DO NOTHING"#;
    let stmt_rel =
        r#"INSERT INTO errata_cve (cve_id, errata_id) VALUES (?1, ?2) ON CONFLICT DO NOTHING"#;

    // first insert the errata
    _ = sqlx::query(stmt_errata)
        .bind(&i_errata_ext.id)
        .bind(&i_errata_ext.date)
        .bind(&i_errata_ext.update_date)
        .bind(&i_errata_ext.advisory_type)
        .bind(&i_errata_ext.advisory_name)
        .bind(&i_errata_ext.advisory_synopsis)
        .execute(i_pool)
        .await;

    for c in i_errata_ext.cves.iter() {
        _ = sqlx::query(stmt_cve).bind(c).execute(i_pool).await;
        _ = sqlx::query(stmt_rel)
            .bind(c)
            .bind(i_errata_ext.id)
            .execute(i_pool)
            .await;
    }

    Ok(())
}

async fn store_cve_affsystem(i_cve: &str, i_num_asys: i32, i_pool: &SqlitePool) -> Result<()> {
    let stmt_cve = r#"INSERT INTO cve (id) VALUES (?) ON CONFLICT (id) DO NOTHING"#;
    let stmt = r#"INSERT INTO cve_systems (cve_id, affected_systems_cnt, last_checked_date) VALUES (?1, ?2, julianday('now'));"#;

    sqlx::query(stmt_cve)
        .bind(i_cve)
        .execute(i_pool)
        .await
        .unwrap();

    sqlx::query(stmt)
        .bind(i_cve)
        .bind(i_num_asys)
        .execute(i_pool)
        .await
        .unwrap();

    Ok(())
}

pub async fn get_errataext() -> Vec<cve_audit_types::ErrataExtended> {
    let mut ere: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let sel = r#"
        with cve_err as (
            select errata_id
                  ,group_concat(cve_id) as cves
            from errata_cve
            group by errata_id
        )
        select e.*,  ce.cves from errata e
        left outer join cve_err ce on ce.errata_id = e.suse_id
        order by e.update_date desc
    "#;

    let mut rows = sqlx::query(sel).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        let id = row.try_get(0).unwrap();
        let erta = cve_audit_types::ErrataExtended {
            id: id,
            date: convert_jd(row.try_get(1).unwrap()),
            update_date: convert_jd(row.try_get(2).unwrap()),
            advisory_synopsis: row.try_get(5).unwrap(),
            advisory_type: row.try_get(3).unwrap(),
            advisory_name: row.try_get(4).unwrap(),
            cves: to_vec_string(row.try_get(5).unwrap()).to_owned(),
            sys_affected: get_aff_sys(&id).await,
        };
        ere.push(erta);
    }
    ere
}

async fn get_linked_cves(i_errata_id: &u32) -> Vec<String> {
    let mut lcves: Vec<String> = Vec::new();

    let sel = r#"
    select id from cve where id in (select cve_id from errata_cve where errata_id = ?); 
    "#;

    let mut rows = sqlx::query(sel).bind(i_errata_id).fetch(&open_pool());

    while let Some(row) = rows.try_next().await.unwrap() {
        lcves.push(row.try_get(0).unwrap());
    }

    lcves
}

async fn get_aff_sys(i_errata_id: &u32) -> bool {
    let sel = r#"
    select sum(affected_systems_cnt) as aff_sys
    from  cve_systems as cs
    where cs.cve_id in (select cve_id from errata_cve where errata_id = ?);
    "#;

    let rec = sqlx::query(sel)
        .bind(i_errata_id)
        .fetch_one(&open_pool())
        .await
        .expect("One row expected");
    let a: i32 = rec.get("aff_sys");
    a > 0
}

pub async fn get_secadvisories(i_kind: SecAdvisoryKind) -> Vec<cve_audit_types::ErrataExtended> {
    let mut sa: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let stmt_aff = r#"
    select *
	from   errata e
	where  e.advisory_type = "Security Advisory"
	and exists (
	  select null
	  from  errata_cve ec
		   ,cve_systems cs
	  where ec.cve_id = cs.cve_id
	  and cs.affected_systems_cnt > 0
	  and ec.errata_id = e.suse_id)
    order by update_date desc;
    "#;

    let stmt_aff_unrated = r#"
    select *
	from   errata e
	where  e.advisory_type = "Security Advisory"
	and exists (
	  select null
	  from  errata_cve ec
		    ,cve_systems cs
	  where ec.cve_id = cs.cve_id
	  and cs.affected_systems_cnt > 0
	  and ec.errata_id = e.suse_id) 
	and not exists (
	  select null from audit_data as ad
	  where ad.errata_id = e.suse_id 
	  and ( ad.assessment in (json_quote('AffectedRegularPatching'), json_quote('NotAffected'),  json_quote('AffectedImmediatePatching'), json_quote('AffectedPatched')) 
        or ad.status != json_quote('Done')
        )
	  )
    order by update_date desc;
    "#;

    let stmt_naff = r#"
    select *
	from   errata e
	where  e.advisory_type = "Security Advisory"
	and not exists (
	  select null
	  from  errata_cve ec
		    ,cve_systems cs
	  where ec.cve_id = cs.cve_id
	  and cs.affected_systems_cnt > 0
	  and ec.errata_id = e.suse_id)
    order by e.update_date desc;
    "#;

    let stmt = match i_kind {
        SecAdvisoryKind::Affected => stmt_aff,
        SecAdvisoryKind::AffectedUnrated => stmt_aff_unrated,
        SecAdvisoryKind::Unaffected => stmt_naff,
    };

    let mut rows = sqlx::query(stmt).fetch(&open_pool());
    while let Some(row) = rows.try_next().await.unwrap() {
        let id = row.try_get(0).unwrap();
        let erta = cve_audit_types::ErrataExtended {
            id: id,
            date: convert_jd(row.try_get(1).unwrap()),
            update_date: convert_jd(row.try_get(2).unwrap()),
            advisory_synopsis: row.try_get(5).unwrap(),
            advisory_type: row.try_get(3).unwrap(),
            advisory_name: row.try_get(4).unwrap(),
            cves: get_linked_cves(&id).await,
            sys_affected: get_aff_sys(&id).await,
        };
        sa.push(erta);
    }

    sa
}

pub async fn get_errata(i_id: u32) -> cve_audit_types::ErrataExtended {
    let mut ere: Vec<cve_audit_types::ErrataExtended> = Vec::new();

    let sel = r#"
      select * from errata where suse_id = ? order by update_date desc
    "#;

    let mut rows = sqlx::query(sel).bind(i_id).fetch(&open_pool());

    // duplicate code!
    while let Some(row) = rows.try_next().await.unwrap() {
        let erta = cve_audit_types::ErrataExtended {
            id: row.try_get(0).unwrap(),
            date: convert_jd(row.try_get(1).unwrap()),
            update_date: convert_jd(row.try_get(2).unwrap()),
            advisory_synopsis: row.try_get(5).unwrap(),
            advisory_type: row.try_get(3).unwrap(),
            advisory_name: row.try_get(4).unwrap(),
            cves: get_linked_cves(&i_id).await,
            sys_affected: get_aff_sys(&i_id).await,
        };
        ere.push(erta);
    }
    let ee = &ere[0];
    ee.clone()
}
