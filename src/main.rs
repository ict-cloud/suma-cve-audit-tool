extern crate log;
extern crate pretty_env_logger;

use tokio::runtime;
use lazy_static::lazy_static;
use crate::settings::settings::Settings;
use crate::server::routes;
use crate::server::garcon;

mod persistence;
mod server;
mod settings;
mod suma;
#[cfg(test)]
mod tests;


lazy_static! {
    pub static ref SETTINGS: Settings = 
        Settings::load();
}

fn main() {
    pretty_env_logger::init();

    let rt = runtime::Runtime::new().unwrap();
    rt.block_on(persistence::rdbms_init::setup()).unwrap();

    // run the api to load the records for inspection
    //match rt.spawn_blocking(move || suma::sumaclient::run_api()) {
    //      Ok(_) => log::info!("SUMA Client API successfully run"),
    //      Err(err) => log::info!("Error in SUMA Client API: {}", err),
    //};
    rt.spawn_blocking( || {async {suma::sumaclient::run_api().await;}});

    let mut handles = Vec::with_capacity(2);

    handles.push(rt.spawn(async {
        garcon::serv(SETTINGS.frontend.listen.as_str(), routes::stat_routes()).await;
    }));
    handles.push(rt.spawn(async {
        garcon::serv(SETTINGS.backend.listen.as_str(), routes::api_routes()).await;
    }));

    println!("Starting webserver on http://{}", SETTINGS.frontend.listen);

    // we need to wait for the handles to return in order to finish the code properly
    // since the warp servers inside the handle stay open, the program should not finish
    // unclear what happens whith errors
    for handle in handles {
        // The `spawn` method returns a `JoinHandle`. A `JoinHandle` is
        // a future, so we can wait for it using `block_on`.
        rt.block_on(handle).unwrap();
    }
    
}
