use serde_derive::{Serialize};
use warp::{http::StatusCode, Rejection, Reply, reject::Reject};
use std::convert::Infallible;


#[derive(Serialize)]
struct ErrorMessage {
    code: u16,
    message: String,
}

#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct UNAUTHORIZED;
impl Reject for UNAUTHORIZED {}
 
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct INTERNAL_SERVER_ERROR;
impl Reject for INTERNAL_SERVER_ERROR {}
 
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct NOT_ACCEPTABLE;
impl Reject for NOT_ACCEPTABLE {}
 
#[allow(non_camel_case_types)]
#[derive(Debug)]
pub struct BAD_REQUEST;
impl Reject for BAD_REQUEST {}

pub async fn handle_rejection(err: Rejection) -> Result<impl Reply, Infallible> {
    let (code, message) = if err.is_not_found() {
        (
            StatusCode::NOT_FOUND,
            "NOT_FOUND"
        ) // return template here?
    } else if let Some(_) = err.find::<warp::reject::MethodNotAllowed>() {
        (
            StatusCode::METHOD_NOT_ALLOWED,
            "METHOD_NOT_ALLOWED"
        )
    } else if let Some(_) = err.find::<UNAUTHORIZED>() {
        (
            StatusCode::UNAUTHORIZED,
            "UNAUTHORIZED"
        )
    } else if let Some(_) = err.find::<NOT_ACCEPTABLE>() {
        (
            StatusCode::NOT_ACCEPTABLE,
            "NOT_ACCEPTABLE"
        )
    } else if let Some(_) = err.find::<BAD_REQUEST>() {
        (
            StatusCode::BAD_REQUEST,
            "BAD_REQUEST"
        )
    } else if let Some(_) = err.find::<INTERNAL_SERVER_ERROR>() {
        // Is this necesary here?
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "INTERNAL_SERVER_ERROR"
        )
    } else {
        eprintln!("unhandled rejection: {:?}", err);
        (
            StatusCode::INTERNAL_SERVER_ERROR,
            "UNHANDLED_REJECTION"
        )
    };
 
    let json = warp::reply::json(&ErrorMessage {
        code: code.as_u16(),
        message: message.into(),
    });
 
    Ok(warp::reply::with_status(json, code))
}