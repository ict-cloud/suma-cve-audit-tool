use core::ops::Deref;
use cve_audit_types::*;
use std::fmt::Display;
use std::str::FromStr;
use wasm_bindgen_futures::spawn_local;
use web_sys::*;
use yew::prelude::*;
use yew_router::history::History;
use yew_router::prelude::*;

#[derive(Properties, PartialEq, Clone)]
pub struct AuditFormProps {
    pub errata_id: u32,
    pub trail_length: usize,
    pub update_list: Callback<Vec<cve_audit_types::ErrataAuditData>>,
}

// see https://discord.com/channels/701068342760570933/703449306497024049/926381991983743037
#[function_component(AuditForm)]
pub fn audit_form(audit_form_props: &AuditFormProps) -> Html {
    let history = use_history().unwrap();
    let errata_id = audit_form_props.errata_id.clone();

    let current_audit_data = use_mut_ref(|| cve_audit_types::ErrataAuditData::default()); // use empty variable here

    // toggle form
    let do_audit = use_state_eq(|| false);
    let onclick_audit_data = current_audit_data.clone();
    let onclick = {
        //*current_audit_data.borrow
        // get current audit entry and fill in variable but should not force a state change
        spawn_local(async move {
            let l_resp: cve_audit_types::ErrataAuditData = reqwasm::http::Request::get(
                format!("/api/errata/{}/auditrecord", &errata_id).as_str(),
            )
            .header("Content-Type", "application/json")
            .send()
            .await
            .unwrap()
            .json()
            .await
            .unwrap();
            // do stuff with the response
            *onclick_audit_data.borrow_mut() = l_resp.to_owned();
        });
        let do_audit = do_audit.clone();
        Callback::from(move |_| do_audit.set(&do_audit.deref().to_owned() != &true))
    };

    // copy the value
    let do_aud_val = do_audit.clone();
    let l_on_audit_trail = audit_form_props.update_list.clone();

    // Form submit event
    let onsubmit = {
        Callback::from(move |e: FocusEvent| {
            e.prevent_default(); // dont do browser auto post
            let form: HtmlFormElement = e.target_unchecked_into();
            let form_data = FormData::new_with_form(&form).expect("Valid form data");
            let local_history = history.clone(); // history needs to be cloned from function component
                                                 // validation of form data?
                                                 // if is_invalid {
                                                 //     return;
                                                 // }
            let body = ErrataAuditData {
                id: 0, //form_data.get("id").into_serde::<u32>().expect("Valid unsigned integer"),
                errata_id: errata_id.clone(), // the id of the errata
                audit_date: String::from(""),
                auditor: form_data
                    .get("auditor")
                    .as_string()
                    .expect("auditor fiel expected string")
                    .to_owned(),
                resp: form_data
                    .get("resp")
                    .as_string()
                    .expect("resp field expected string")
                    .to_owned(),
                status: AuditStatus::from_str(
                    &form_data
                        .get("status")
                        .as_string()
                        .expect("status field expected string"),
                )
                .unwrap(),
                assessment_verdict: AuditAssessment::from_str(
                    &form_data
                        .get("assessment_verd")
                        .as_string()
                        .expect("assessment_verd field expected string"),
                )
                .unwrap(),
                assessed_score: form_data
                    .get("assess_score")
                    .as_string()
                    .unwrap_or_default()
                    .parse::<f32>()
                    .unwrap_or_default(), // string needs to be parsed, other methods are unsafe
                assessment_comment: form_data
                    .get("assess_comment")
                    .as_string()
                    .expect("assess_comment expected string")
                    .to_owned(),
            };
            // fetching is asynchronous so we spawn a wasm_bindgen thread https://yew.rs/docs/tutorial#fetching-data-using-external-rest-api
            // call back from parent needs to be cloned to fulfill Fn of closure
            // otherwise we would have an FnOnce
            let tmp_on_audit_trail = l_on_audit_trail.clone();
            spawn_local(async move {
                let l_resp: Vec<cve_audit_types::ErrataAuditData> =
                    reqwasm::http::Request::post("/api/audit/submit")
                        .header("Content-Type", "application/json")
                        .body(serde_json::to_string(&body).unwrap())
                        .send()
                        .await
                        .unwrap()
                        .json()
                        .await
                        .unwrap();
                // do stuff with the response
                tmp_on_audit_trail.emit(l_resp.clone());
            });

            // toggle form back to invisible
            do_audit.set(*do_audit != true);

            // all good replace the original route to reload page
            local_history.replace(crate::route::AppRoute::Errata {
                i_errata_id: errata_id,
            });
        })
    };

    let current_data = current_audit_data.take();

    html! {
      if *do_aud_val {
        {render_form(onsubmit, current_data)}
      } else if audit_form_props.trail_length > 0 {
            <>
            <button {onclick} class="btn btn-primary">{"Edit"}</button>
            </>
      } else {
            <button {onclick} class="btn btn-primary">{"Add"}</button>
      }
    }
}

fn render_form(onsubmit: yew::Callback<yew::FocusEvent>, current_data: ErrataAuditData) -> Html {
    let status_options = vec![AuditStatus::New, AuditStatus::InProgress, AuditStatus::Done];
    let assess_options = vec![
        AuditAssessment::Unclear,
        AuditAssessment::NotAffected,
        AuditAssessment::AffectedRegularPatching,
        AuditAssessment::AffectedImmediatePatching,
        AuditAssessment::AffectedPatched,
    ];
    html! {
          <div class="col-md-7 col-lg-8">
            <form method="post" {onsubmit} class="needs-validation">
              <div class="row mb-6">
                <div class="col-sm-6">
                  <label for="auditor" class="form-label">{"Auditor"}</label>
                  <input type="text" name="auditor" id="auditor" class="form-control" value={current_data.auditor} />
                </div>
                <div class="col-sm-6">
                  <label for="resp" class="form-label">{"Responsible"}</label>
                  <input type="text" name="resp" id="resp" class="form-control" value={ current_data.resp } />
                </div>
              </div>
              <div class="col-12">
                <label for="assess_score" class="form-label">{"Score"}</label>
                <input type="number" min="0.0" max="10.0" step="0.1" name="assess_score" id="assess_score" class="form-control" value={ current_data.assessed_score.to_string() } />
              </div>
              <div class="col-12">
                <label for="status" class="form-label">{"Status"}</label>
                <select name="status" id="status" class="form-select">
                  {render_options(status_options, current_data.status)
    }
                </select>
              </div>
              <div class="col-12 mb-6">
                <label for="assessment_verd" class="form-label">{"Assessment"}</label>
                <select name="assessment_verd" id="assessment_verd" class="form-select">
                  {render_options(assess_options, current_data.assessment_verdict)}
                </select>
              </div>
              <div class="col-12 mb-3">
                <label for="assess_comment" class="form-label">{"Remarks"}</label>
                <textarea name="assess_comment" id="assess_comment" class="form-control" rows="4" value={ current_data.assessment_comment } ></textarea>
              </div>
              <div class="col-12">
                <button type="submit" class="btn btn-primary">{"Save"}</button>
              </div>
            </form>
          </div>
        }
}

fn render_options<T: Display + std::cmp::PartialEq>(
    i_options: Vec<T>,
    i_current_option: T,
) -> Html {
    html! {
      {
          i_options.into_iter().map(|opt| {
          if opt == i_current_option {
           html!{<option selected=true>{opt.to_string()}</option>}
          } else {
            html!{<option>{opt.to_string()}</option>}
          }
        }).collect::<Html>()
      }
    }
}
