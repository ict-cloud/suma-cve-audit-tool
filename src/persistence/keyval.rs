use std::ops::Deref;
use std::collections::{hash_map::DefaultHasher, BTreeMap};
use std::hash::{Hash, Hasher};
use cve_audit_types::*;

// Constants
const STORE_NAME: &str = "./db/suse_cve.sled";

pub fn open_db(ref_store: Option<sled::Db>) -> sled::Db {
  let db = match ref_store {
    Some(ref_store) => { ref_store },
    None => { sled::open(STORE_NAME).unwrap() }
  };

  db 
}

fn open_tree(store: Option<sled::Db>, i_tree: &str) -> sled::Tree {
  let db = open_db(store);
  db.open_tree(i_tree).unwrap()
}

fn open_clean_tree(store: Option<sled::Db>, i_tree: &str) -> sled::Tree {
  let db = open_db(store);
  let tree = db.open_tree(i_tree).unwrap();
  tree.clear().unwrap();
  db.flush().unwrap();
  tree
}

fn get_treename(i_key: &str) -> String {
  let (tn, _) = i_key.split_once("|").unwrap();
  tn.to_owned()
}

// pub fn upsert(ky: &str, vl: cve_audit_types::CVE, i_db: Option<sled::Db>) -> sled::Result<()> {
//   let db = open_db(i_db);

//   //let tree = db.open_tree(b"ky")?;

//   // rewrite logic to use trees
//   // under the tree the url will be the key and the title will be the value.
//   // retrieving the values is only possible by prefixing the key with the tree to get the right value  
//   // here the vector needs to be serialized to binary/u8 for the insert
//   //insert_to_tree(ky.clone(), vl.clone(), db.clone())?;
//   db.flush()?;  
//   Ok(())
// }

pub fn batch_insert(i_tree: &str, i_cve_list: BTreeMap<String, CVE>, i_db: Option<sled::Db>) -> sled::Result<()> {
  let db = open_db(i_db);
  let tree = db.open_tree(i_tree.as_bytes())?;
  
  // batch insert
  let mut batch = sled::Batch::default();

  for (key, cve) in i_cve_list.iter() {
    let bv = bincode::serialize(&cve).unwrap();
    batch.insert(key.as_bytes(), bv);
  }

  let e = tree.apply_batch(batch);
  if e.is_err() {
    println!("Error tree apply batch {:?}", e);
  }
  tree.flush()?;
  Ok(())
}


pub fn get(ky: &str, db: Option<sled::Db>) -> cve_audit_types::CVE {
   // will return a CVE
   let db = open_db(db);
   let jal: cve_audit_types::CVE = bincode::deserialize(db.get(ky).unwrap().unwrap().deref()).unwrap();

   db.flush().unwrap();

   jal
}

pub fn get_from(ky: &str, store: &sled::Db) -> cve_audit_types::CVE {
   let jal: cve_audit_types::CVE = bincode::deserialize(store.get(ky).unwrap().unwrap().deref()).unwrap();
   jal
}

pub fn get_all(store: Option<sled::Db>) -> Vec<cve_audit_types::CVE> {
  let mut cves: Vec<cve_audit_types::CVE> = Vec::new();
  //let datastore = open_db(store);
  let datastore = open_tree(store, "NEW");

  for cvelist in datastore.iter().values() {
    let v = cvelist.unwrap();
    cves.push(bincode::deserialize(v.deref()).unwrap());
  }
  cves
}

//pub fn get_list_for_tree(tree: )
// make generic function where just the enum can be provided.
// for this the enums from cve-audit-types need to implement a trait
// like this it does not matter which concrete enum they are

fn calc_hash<T: Hash>(t: &T) -> u64 {
  let mut s = DefaultHasher::new();
  t.hash(&mut s);
  s.finish()
}

pub fn get_cve(kh: &str, i_db: Option<sled::Db>) -> Vec<cve_audit_types::CVE> {
  let db = open_db(i_db);
  let tn = get_treename(kh);
  let tree = db.open_tree(tn.as_bytes()).unwrap();
  let j: cve_audit_types::CVE = bincode::deserialize(tree.get(kh).unwrap().unwrap().deref()).unwrap();
  vec![j]
}