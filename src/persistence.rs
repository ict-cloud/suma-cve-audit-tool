use std::ops::Deref;
use std::collections::hash_map::DefaultHasher;
use std::hash::{Hash, Hasher};
use cve_audit_types::*;

// Constants
const STORE_NAME: &str = "./db/suse_cve.sled";

pub fn open_db(ref_store: Option<sled::Db>) -> sled::Db {
  let db = match ref_store {
    Some(ref_store) => { ref_store },
    None => { sled::open(STORE_NAME).unwrap() }
  };

  db 
}

fn open_tree(store: Option<sled::Db>, i_tree: &str) -> sled::Tree {
  let db = open_db(store);
  db.open_tree(i_tree).unwrap()
}

fn open_clean_tree(store: Option<sled::Db>, i_tree: &str) -> sled::Tree {
  let db = open_db(store);
  let tree = db.open_tree(i_tree).unwrap();
  tree.clear().unwrap();
  db.flush().unwrap();
  tree
}

fn get_treename(i_key: &str) -> String {
  let (tn, _) = i_key.split_once("|").unwrap();
  tn.to_owned()
}

pub fn upsert(ky: &str, vl: cve_audit_types::CVE, i_db: Option<sled::Db>) -> sled::Result<()> {
  let db = open_db(i_db);

  //let tree = db.open_tree(b"ky")?;

  // rewrite logic to use trees
  // under the tree the url will be the key and the title will be the value.
  // retrieving the values is only possible by prefixing the key with the tree to get the right value  
  // here the vector needs to be serialized to binary/u8 for the insert
  insert_to_tree(ky.clone(), vl.clone(), db.clone())?;
  db.flush()?;  
  Ok(())
}

 fn insert_to_tree(tk: &str, val: cve_audit_types::CVE, db: sled::Db) -> sled::Result<()> {
//   let tree = db.open_tree(tk.as_bytes())?;
//   // clear tree
//   tree.clear().unwrap();
//   db.flush().unwrap();
//   let mut batch = sled::Batch::default();

//   for mut v in val.job_ads {

//     if v.id.trim().is_empty() {
//       v.id = format!("{}|{}", tk, calc_hash(&v.url)).to_owned();
//     }
//     //println!("insert_to_tree {:?}", &v);
//     let bv = bincode::serialize(&v).unwrap(); 
//     batch.insert(v.id.as_bytes(), bv);
//   }

//   let e = tree.apply_batch(batch);
//   if e.is_err() {
//     println!("Error tree apply batch {:?}", e);
//   }
//   tree.flush()?;
   Ok(())
}


pub fn get(ky: &str, db: Option<sled::Db>) -> cve_audit_types::CVE {
   // will return a CVE
   let db = open_db(db);
   let jal: cve_audit_types::CVE = bincode::deserialize(db.get(ky).unwrap().unwrap().deref()).unwrap();

   db.flush().unwrap();

   jal
}

pub fn get_from(ky: &str, store: &sled::Db) -> cve_audit_types::CVE {
   let jal: cve_audit_types::CVE = bincode::deserialize(store.get(ky).unwrap().unwrap().deref()).unwrap();
   jal
}

pub fn get_all(store: Option<sled::Db>) -> Vec<cve_audit_types::CVE> {
  let mut jav: Vec<cve_audit_types::CVE> = Vec::new();
  let datastore = open_db(store);

  for cvelist in datastore.iter().values() {
    let v = cvelist.unwrap();
    jav.push(bincode::deserialize(v.deref()).unwrap());
  }
  jav
}

//pub fn get_list_for_tree(tree: )
// make generic function where just the enum can be provided.
// for this the enums from cve-audit-types need to implement a trait
// like this it does not matter which concrete enum they are

fn calc_hash<T: Hash>(t: &T) -> u64 {
  let mut s = DefaultHasher::new();
  t.hash(&mut s);
  s.finish()
}

pub fn get_cve(kh: &str, i_db: Option<sled::Db>) -> Vec<cve_audit_types::CVE> {
  let db = open_db(i_db);
  let tn = get_treename(kh);
  let tree = db.open_tree(tn.as_bytes()).unwrap();
  let j: cve_audit_types::CVE = bincode::deserialize(tree.get(kh).unwrap().unwrap().deref()).unwrap();
  vec![j]
}