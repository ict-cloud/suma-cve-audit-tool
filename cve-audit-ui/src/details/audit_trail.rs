use yew::prelude::*;
use cve_audit_types::*;
use crate::details::audit_form::*;

#[derive(Properties, PartialEq)]
pub struct AuditTrailProps {
    pub errata_id: u32,
}

#[function_component(AuditTrailEntry)]
pub fn audit_trail_entry(audit_trail_props: &AuditTrailProps) -> Html {
    let empty_trail = cve_audit_types::ErrataAuditData{
        id: 0,
        errata_id: 0,
        audit_date: String::from("2022-01-01"),
        auditor: String::from(""),
        resp: String::from(""),
        status: AuditStatus::New,
        assessment_verdict: AuditAssessment::Unclear,
        assessed_score: 0.0,
        assessment_comment: String::from(""),
    };
    let audit_trail = use_state(|| empty_trail);
    let url = format!("http://localhost:8081/api/errata/{}/audittrail", audit_trail_props.errata_id);
    {
        let audit_trail = audit_trail.clone();
        use_effect_with_deps(move |url| {
            let audit_trail = audit_trail.clone();
            let url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_at: cve_audit_types::ErrataAuditData = reqwasm::http::Request::get(url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                audit_trail.set(fetched_at);
            });
            || ()
        }, url.clone());
    }

    html! {
        <div>
            {"List"}
            {render_item(audit_trail)}
        </div>
    }
}

#[function_component(AuditTrailList)]
pub fn audit_trail_list(audit_trail_props: &AuditTrailProps) -> Html {
    let audit_trail = use_state(|| vec![]);
    //let url = use_state(|| String::from(""));
    log::info!("audit_trail_list render triggered");
    let url = format!("http://localhost:8081/api/errata/{}/audittrail", audit_trail_props.errata_id);
    {
        let l_audit_trail = audit_trail.clone();
        use_effect_with_deps(move |url| {
            let audit_trail2 = l_audit_trail.clone();
            let l_url = url.clone();
            wasm_bindgen_futures::spawn_local(async move {
                let fetched_at: Vec<cve_audit_types::ErrataAuditData> = reqwasm::http::Request::get(l_url.as_str())
                    .send()
                    .await
                    .unwrap()
                    .json()
                    .await
                    .unwrap();
                audit_trail2.set(fetched_at);
            });
            || ()
        }, url.clone());
    }

    //let audit_trail2 = audit_trail.clone();
    // let on_audit_trail: Callback<Vec<cve_audit_types::ErrataAuditData>> = Callback::from(move |audit_trail_v: Vec<cve_audit_types::ErrataAuditData>| {
    //     log::info!("callback executed {}", audit_trail_v.len());
    //     let l_audit_trail = audit_trail2.clone();
    //     l_audit_trail.set(audit_trail_v)
    // });

    //let url_new = url.clone();
    let on_url: Callback<String> = Callback::from(move |new_url: String| {
        log::info!("callback executed {}", new_url);
    });

    html!{
        <div>
            <h2>{"List"}</h2>
            {render_list(audit_trail.clone())}
            <hr/>
            <AuditForm errata_id={audit_trail_props.errata_id} trail_length={audit_trail.len()} tail_list={on_url} />
        </div>
    }
}

fn render_list(audit_trail: yew::UseStateHandle<Vec<cve_audit_types::ErrataAuditData>>) -> Html {
    html! {
        <div class={classes!("list", "table-responsive")}>
          <table class={classes!("table", "table-striped", "table-sm")}>
            <thead>
              <tr>
                <th scope={"col"}>{"Date"}</th>
                <th scope={"col"}>{"Status"}</th>
                <th scope={"col"}>{"Assessment"}</th>
                <th scope={"col"}>{"Assessed Score"}</th> 
                <th scope={"col"}>{"Auditor"}</th>
                <th scope={"col"}>{"Responsible"}</th>
              </tr>
            </thead>
            <tbody>
            { audit_trail.iter().map(|c| render_line(c)).collect::<Html>() }
            </tbody>
          </table>
        </div>
    }
}

fn render_line(line_item: &cve_audit_types::ErrataAuditData) -> Html {
    html! {
        <tr>
          <td>{&line_item.audit_date}</td>
          <td>{&line_item.status}</td>
          <td>{&line_item.assessment_verdict}</td>
          <td>{&line_item.assessed_score}</td>
          <td>{&line_item.auditor}</td>
          <td>{&line_item.resp}</td>
        </tr>
    }
}

fn render_item(audit_trail: yew::UseStateHandle<cve_audit_types::ErrataAuditData>) -> Html {
    let aud_trail = &*audit_trail.clone();
    if aud_trail.id != 0 {
        html! {
            <div class={classes!("list", "table-responsive")}>
              <table class={classes!("table", "table-striped", "table-sm")}>
                <thead>
                  <tr>
                    <th scope={"col"}>{"Date"}</th>
                    <th scope={"col"}>{"Status"}</th>
                    <th scope={"col"}>{"Assessment"}</th>
                    <th scope={"col"}>{"Assessed Score"}</th> 
                    <th scope={"col"}>{"Auditor"}</th>
                    <th scope={"col"}>{"Responsible"}</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>{&aud_trail.audit_date}</td>
                    <td>{&aud_trail.status}</td>
                    <td>{&aud_trail.assessment_verdict}</td>
                    <td>{&aud_trail.assessed_score}</td>
                    <td>{&aud_trail.auditor}</td>
                    <td>{&aud_trail.resp}</td>
                  </tr>
                </tbody>
              </table>
            </div>
        }
    } else {
        html! {
            <div class={classes!("loading")}>{"loading..."}</div>
        }
    }
}