use rusqlite::{Connection, Result, params};
//use sqlx::Connection;
use cve_audit_types::*;


// Constants
const DB_NAME: &str = "./db/suse_errata.sqlite";
//const DB_NAME: &str = "sqlite:./db/suse_errata.sqlite";

/*  SETUP of Relational database
* suse_errata
*    data from suse errata
* 
*  CVE
*    data for CVE (id, name, score)
*
*  Audit Evaluation
*    Data of the evaluation
*    date, person, result, 
*
*  errata_cve
*    Relations from errata to cve
*  
*  errata_audit
*    Relations from errata to audits
*
*  cve_systems
*    systems affected by cve
*/ 
fn open_db() -> Connection {
    Connection::open(DB_NAME).unwrap()
}

pub fn setup() -> Result<()> {
    //let conn = SqliteConnection::connect(DB_NAME);
    //let conn = SqliteConnection::establish(DB_NAME);
    let conn = open_db();

    let setup_stmt = r#"
        begin;
            CREATE TABLE IF NOT EXISTS errata (
                id INTEGER PRIMARY KEY,
                suse_id INTEGER UNIQUE,
                date TEXT NOT NULL,
                update_date TEXT NOT NULL,
                advisory_type TEXT,
                advisory_name TEXT NOT NULL UNIQUE,
                advisory_synopsis TEXT
            );
            CREATE TABLE IF NOT EXISTS cve (
                id TEXT PRIMARY KEY,
                score REAL
            );
            CREATE TABLE IF NOT EXISTS errata_cve (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                errata_id INTEGER NOT NULL REFERENCES ERRATA(id)
            );
            CREATE TABLE IF NOT EXISTS cve_systems (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                affected_systems_cnt INTEGER,
                last_checked TEXT
            );
        COMMIT;
    "#;

    match conn.execute_batch(setup_stmt) {
        Ok(()) => println!("tables created"),
        Err(err) => println!("failed: {}", err),
    };

    Ok(())
}

pub fn store_errata(i_errata: cve_audit_types::Errata) -> Result<()> {
    let conn = open_db();
    let stmt = r#"INSERT INTO errata VALUES (?1, ?2, ?3, ?3, ?4, ?5, ?6)"#;

    match conn.execute(&stmt, params![i_errata.id, i_errata.date, i_errata.update_date, i_errata.advisory_type, i_errata.advisory_name, i_errata.advisory_synopsis],)
    {
        Ok(inserted) => println!("{} rows were inserted", inserted),
        Err(err) => println!("insert failed: {}", err),
    };

    Ok(())
}

pub fn store_cve(i_errata_ext: &cve_audit_types::ErrataExtended) -> Result<()> {
    let conn = open_db();
    let stmt = r#"INSERT INTO cve (id) VALUES (?) ON CONFLICT (id) DO NOTHING"#;
    let stmt_rel = r#"INSERT INTO errata_cve (cve_id, errata_id) VALUES (?1, ?2)"#;

    for c in i_errata_ext.cves.iter() {
        match conn.execute(stmt, params![c]) {
            Ok(inserted) => println!("{} rows were inserted", inserted),
            Err(err) => println!("update failed: {}", err),
        };
        match conn.execute(stmt_rel, params![c, i_errata_ext.id]) {
            Ok(inserted) => println!("{} rows were inserted", inserted),
            Err(err) => println!("update failed: {}", err),
        };
    }

    Ok(())
}

