use crate::persistence::utils::convert_jd;
use crate::persistence::rdbms::open_pool;
use cve_audit_types::*;
use sqlx::{Row, Result};
//use futures::TryStreamExt;

pub async fn get_audit_for_errata(i_errata_id: u32) -> ErrataAuditData {

    let sel = r#"
      select * from audit_data where errata_id = ?
    "#;
    let conn = open_pool();

    let rows = sqlx::query(sel)
        .bind(i_errata_id)
        .fetch_optional(&conn).await.unwrap();
    let ead: ErrataAuditData = if let Some(row) = rows {
        ErrataAuditData{
            id: row.try_get(0).unwrap(),
            errata_id: row.try_get(1).unwrap(),
            audit_date: convert_jd(row.try_get(2).unwrap()),
            auditor: row.try_get(3).unwrap(),
            resp: row.try_get(4).unwrap(),
            status: serde_json::from_str(row.try_get(5).unwrap()).unwrap(),//AuditStatus::New, // needs to be annotated a sqlx::type
            assessment_verdict: serde_json::from_str(row.try_get(6).unwrap()).unwrap(),
            assessed_score: row.try_get(7).unwrap(),
            assessment_comment: row.try_get(8).unwrap()
        }
      } else {
        ErrataAuditData{
            id: 0,
            errata_id: 0,
            audit_date: String::from(""),
            auditor: String::from(""),
            resp: String::from(""),
            status: AuditStatus::New,
            assessment_verdict: AuditAssessment::Unclear,
            assessed_score: 0.0,
            assessment_comment: String::from("")
        }
    };

    ead
}

pub async fn write_audit_data(i_ad: ErrataAuditData) -> Result<()> {
    println!("Form data for writing received {:?}", i_ad);
    Ok(())
}