use sqlx::prelude::*;
use sqlx::Result;
use sqlx::sqlite::{SqliteConnectOptions};
use crate::persistence::rdbms::*;
use std::str::FromStr;

fn prereq_db_file() {
    // create db path if it not exists
    println!("path is {}", db_path().as_str());
    if !std::path::Path::new(db_path().as_str()).exists() {
        match std::fs::create_dir(db_path().as_str()) {
            Err(e) => log::error!("Unable to create directory: {}", e),
            Ok(()) => log::info!("Directory created"),
        };
    }
}

pub async fn setup() -> Result<()> {

    prereq_db_file();

    let setup_stmt = r#"
        begin;
            CREATE TABLE IF NOT EXISTS errata (
                suse_id INTEGER UNIQUE,
                date REAL NOT NULL,
                update_date REAL NOT NULL,
                advisory_type TEXT,
                advisory_name TEXT NOT NULL UNIQUE,
                advisory_synopsis TEXT
            );
            CREATE TABLE IF NOT EXISTS cve (
                id TEXT PRIMARY KEY,
                score REAL
            );
            CREATE TABLE IF NOT EXISTS errata_cve (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id)
            );
            CREATE TABLE IF NOT EXISTS cve_systems (
                id INTEGER PRIMARY KEY,
                cve_id TEXT NOT NULL REFERENCES cve(id),
                affected_systems_cnt INTEGER,
                last_checked_date REAL
            );
            CREATE TABLE IF NOT EXISTS audit_data (
                id integer primary key,
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
                audit_date REAL NOT NULL,
                auditor TEXT,
                responsible TEXT,
                status TEXT NOT NULL,
                assessment TEXT NOT NULL,
                assess_score REAL,
                assessment_comment TEXT
            );
            CREATE TABLE IF NOT EXISTS audit_trail (
                id integer primary key,
                new_id INTEGER NOT NULL REFERENCES audit_data(id),
                errata_id INTEGER NOT NULL REFERENCES ERRATA(suse_id),
                audit_date REAL NOT NULL,
                auditor TEXT,
                responsible TEXT,
                status TEXT NOT NULL,
                assessment TEXT NOT NULL,
                assess_score REAL,
                assessment_comment TEXT
            );
        COMMIT;
    "#;

    let full_path = format!("{}/{}", db_path(), DB_NAME);

    println!("full_path is: {}", &full_path);

    let mut conn = SqliteConnectOptions::from_str(&full_path)?
        .create_if_missing(true)
        .connect().await?;
    
    _= match sqlx::query(setup_stmt).execute(&mut conn).await {
        Ok(_)   => Ok(()),
        Err(e) => Err(e),
    };

    conn.close();

    Ok(())
    
}